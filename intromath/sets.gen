§template(
  <link rel="stylesheet" href="./assets/euler_diagrams.css">
  <script defer src="./assets/katex.min.js"></script/>

  <script defer src="./assets/euler_diagrams.js" type="module"></script>

  <style>
    #first_venn > circle {
      stroke: var(--color-text);
      fill: none;
    }

    #first_venn > foreignObject {
      pointer-events: none;
    }

    .first_venn_region {
      stroke: none;
      fill: rgba(0, 0, 0, 0);
    }

    .first_venn_region:hover {
      fill: url("#pattern_striped");
    }

    #duck_region {
      cursor: pointer;
    }

    #duck_container {
      width: 0px;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #duck_container.active_duck {
      animation: duck_zoom 8s ease 0s 1 normal forwards, duck_rotate 0.91s ease 0s infinite alternate forwards;
    }

    @keyframes duck_zoom {
      0% {
        width: 0px;
      }

      50% {
        width: 100vw;
      }

      100% {
        width: 0px;
      }
    }

    @keyframes duck_rotate {
      0% {
        transform: translate(-50%, -50%) rotate(-20deg);
      }

      100% {
        transform: translate(-50%, -50%) rotate(20deg);
      }
    }
  </style>
)(
  §hsection["chapter_sets"](Naïve Set Theory)(
    §p(
      In the §cref(chapter_deductive_reasoning)(previous chapter) we examined how to formulate, prove, and disprove statements. The example statements we looked at talked about numbers and squirrel, but the principles we examined apply regardless of which objects the statements talk about. In this chapter, we examine a class of objects that is so powerful that we can express everything from numbers to computers to proofs themselves in it. This class of objects will provide the foundation for everything we will study throughout this book.
    )§p(
      Such a universal domain will allow us to apply very general concepts to arbitrarily specific situations. And yet you will find that the objects our statements will talk about are in themselves very simple. Striking that balance between simplicity and universality of foundational objects was arguably one of the key achievements of the 20th century: the development of §em(set theory).
    )

    §hsection["section_sets"](Sets)(
      §p(
        When attempting to define the foundations of mathematics, you run into a chicken-egg problem: Any definition needs to make use of mathematical concepts, so in particular the definition of the foundational objects also requires prior definitions. But then it clearly is not foundational.
      )§p(
        While there are sophisticated ways of avoiding this problem, they require a good understanding of mathematics to begin with. So we instead follow the traditional approach in teaching: Our very first definition will be slightly informal, and we will simply pretend that it was sufficiently precise. Hence the §verbatim(naïve) in the chapter title §verbatim(naïve set theory).
      )§p(
        In particular, we will talk about mathematical §verbatim(objects), without specifically stating what those are. For our purposes, we require that an object is §r(equal) to itself but not to anything else. The number §$(17)(,) for example, is a mathematical object.
      )§p(
        Furthermore, an object must be §verbatim(well-defined), that is, it must be clear, for the purposes of determining §r(equal)(equality), which object you are talking about. For example, §verbatim(the most important composer of the 18th century) is not well-defined; whether the most important composer of the 18th century is §r(equal) to §link(Johann Sebastian Bach)(https://en.wikipedia.org/wiki/Johann_Sebastian_Bach) is a matter of personal opinion, not mathematical reasoning.
      )§p(
        We will use squirrel-related iconography for our mathematical objects: §$(§$symbol0§ , §$symbol1§ , §$symbol2§ , §$symbol3)(,) and §$(§$symbol4)(.) But now it is high time to look at the one definition on which everything else in this book will build upon:
      )

      §definition["set"](Set)(
        §set_math_id["set", "set"]
        §p(
          A §define(set) is a collection of objects, characterized solely by which objects belong to it, and which objects do not.
        )§p(
          We denote a §r(set) by listing its objects within curly braces, separated by commas, for example: §$(§$set(§$symbol0)(§$symbol1)(§$symbol2))(.)
        )§p(
          The §define(empty set) §$(§$set()) — the collection that contains no objects at all — is also written as §$(§$set)(.)
        )
      )

      §p(
        Because a §r(set) is characterized by the objects that belong to it, §$(§$set(§$symbol0)(§$symbol1)) and §$(§$set(§$symbol1)(§$symbol0)) are two different ways of denoting the same §r(set). Informally speaking, §rs(set) ignore the order of their objects. Furthermore, §$(§$set(§$symbol0)(§$symbol1)(§$symbol0)) and §$(§$set(§$symbol0)(§$symbol1)) also denote the same §r(set), you could say that §rs(set) ignore duplicates. All three expressions are simply different ways of denoting the unique mathematical object characterized by the fact that §$(§$symbol0) and §$(§$symbol1) belong to it, but nothing else does.
      )§p(
        After the build-up about the foundational concept that is able to express anything you could possibly dream up, the notion of §rs(set) might be a bit of a letdown at first glance. We will get to the reasons for why §rs(set) are a very powerful concept soon enough, but first, we define and inspect some elementary terminology and notions.
      )

      §definition["set_membership"](Set Membership)(
        §set_math_id["in", "set_membership"]
        §set_math_id["notin", "set_membership"]
        §p(
          To express that an object §$(x) occurs in a §r(set) §$(X)(,) we write §$(x §$in X)(,) and we say that §verbatim(§$(x) is an §define(element) of §$(X)), §verbatim(§$(x) is a §define(member) of §$(X)), or simply that §verbatim(§$(x) §define(in) §$(X)).
        )§p(
          If not §$(x §$in X)(,) we write §$(x §$notin X)(.)
        )
      )

      §example["example_set_membership"](
        §$(§$symbol0 §$in §$set(§$symbol0)(§$symbol1))(,) §$(§$symbol1 §$in §$set(§$symbol0)(§$symbol1))(,) and §$(§$symbol2 §$notin §$set(§$symbol0)(§$symbol1))(.)
      )

      §p(
        We can visualize §rs(member)(set membership) by drawing §rs(set) as blobs that enclose their §rs(element). §cref(example_euler_diagram) demonstrates such an §definex["euler_diagram"](Euler diagram)(
          §p(
            An §rdef(Euler diagram) visualizes §rs(member)(set membership) by drawing §rs(set) as blobs that enclose their §rs(element).
          )
          §input["euler_diagrams/vanilla_no_controls.html"]
        ). Note how the idea of a §r(set) containing §rs(element) multiple times or in a particular order cannot even be expressed in these depictions, making §rs(Euler diagram) a more faithful representations of §rs(set) than our written notation.
      )

      §div(slightlywide)(
        §example["example_euler_diagram"](Euler Diagram)(
          §captioned(
            §input["euler_diagrams/vanilla.html"]
          )(
            §p(An interactive §r(Euler diagram) showing two §rs(set). Toggle the buttons to change the depicted §rs(set).)
          )
        )
      )

      §hsection["subsection_set_equality"](Set Equality)(
        §p(
          Based on the notion of §r(member)(set membership), we can define precisely when two §rs(set) are considered equal.
        )

        §definition["set_eq"](Set Equality)(
          §set_math_id["seq", "set_eq"]
          §set_math_id["sneq", "set_eq"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )
          §p(
            We say §$(A) and §$(B) are §define["", "sequal"](equal)(equal), written as §$(A §$seq B)(,) if for all §$(x) we have §$(x §$in A) if and only if §$(x §$in B)(.)
          )§p(
             If not §$(A §$seq B)(,) we write §$(A §$sneq B)(.)
          )
        )

        §p(
          Take a moment to consider some equivalent formulations to the §verbatim(if and only if) in §cref(set_eq):
        )
        §ul(
          §li(§$(A §$seq B) if every §$(x §$in A) is §r(in) §$(B) and every §$(x §$in B) is §r(in) §$(A)(.))
          §li(§$(A §$seq B) if every §$(x §$in A) is §r(in) §$(B) and every §$(x §$notin A) is not §r(in) §$(B)(.))
          §li(§$(A §$seq B) if every §$(x) is either §r(in) both §$(A) and §$(B) or §r(in) neither.)
        )
        §p(
          All of these ways of looking at §r(sequal)(set equality) can come in handy when trying to prove that two complex descriptions of §rs(set) actually describe the same one. §cref(example_seq) visualizes the third interpretation.
        )

        §div(slightlywide)(
          §example["example_seq"](Set Equality)(
            §captioned(
              §input["euler_diagrams/equality.html"]
            )(
              §p(
                Two §rs(set), the §rs(element) that occur in exactly one of them are §span{"class": "s3"}(highlighted). You can change the §rs(set), note how the §rs(set) are §r(sequal) exactly if no such §span{"class": "s3"}(highlighted) §rs(element) remain.
              )
            )
          )
        )

        §p(
          Equipped with a precise definition of §r(sequal)(set equality), we can now prove some fundamental properties of §r(sequal) §rs(set).
        )

        §theorem["seq_reflexivity"](Reflexivity of §$(§$seq[true]))(
          §p(
            Let §$(A) be a §r(set), then §$(A §$seq A).
          )
        )
        §proof["seq_reflexivity"](
          §proof_part(
            §verbatim(§$(a §$in A §$implies a §$in A)):
          )(
            §p(
              Let §$(a §$in A)(,) then §$(a §$in A) by assumption.
            )
          )
          §proof_part(
            §verbatim(§$(a §$notin A §$implies a §$notin A)):
          )(
            §p(
              Let §$(a §$notin A)(,) then §$(a §$notin A) by assumption.
            )
          )
        )

        §theorem["seq_symmetry"](Symmetry of §$(§$seq[true]))(
          §p(
            Let §$(A, B) be §rs(set). If §$(A §$seq B)(,) then §$(B §$seq A)(.)
          )
        )
        §proof["seq_symmetry"](
          §p(
            Assume that §$(A §$seq B)(,) that is, assume that §$(x §$in A) implies §$(x §$in B)(,) and that §$(x §$in B) implies §$(x §$in A)(.) Then by the §r(commutative conjunction)(commutativity of conjunctions) we also have that §$(x §$in B) implies §$(x §$in A) and §$(x §$in A) implies §$(x §$in B)(,) that is, §$(B §$seq A)(.)
          )
        )

        §theorem["seq_transitivity"](Transitivity of §$(§$seq[true]))(
          §p(
            Let §$(A, B, C) be §rs(set). If §$(A §$seq B) and §$(B §$seq C)(,) then §$(A §$seq C)(.)
          )
        )
        §proof["seq_transitivity"](
          §p(
            Assume that §$(A §$seq B) and §$(B §$seq C)(.)
          )
          §proof_part(
            §verbatim(§$(a §$in A §$implies a §$in C)):
          )(
            §p(
              Let §$(x §$in A)(,) then
            )§fleqn(
              §$$align*(
                && x &§$in A
              )(
                §$implies {} && x &§$in B §$tag($A §$seq B$)
              )(
                §$implies {} && x &§$in C. §$tag($B §$seq C$)
              )
            )
          )
          §proof_part(
            §verbatim(§$(a §$notin A §$implies a §$notin C)):
          )(
            §p(
              Let §$(x §$notin A)(,) then
            )§fleqn(
              §$$align*(
                && x &§$notin A
              )(
                §$implies {} && x &§$notin B §$tag($A §$seq B$)
              )(
                §$implies {} && x &§$notin C. §$tag($B §$seq C$)
              )
            )
          )
        )

        §p(
          These properties might feel so self-evidently true (just picture the §rs(Euler diagram)) that it can initially be hard to know where to even begin proving them. So while these proofs might not be the most flashy ones, it is quite remarkable that we can rigorously reason about such fundamental properties rather than having to blindly accept them as true.
        )

        §exercise["transitivity_sneq"](
          §p(
            Let §$(A, B, C) be §rs(set). Prove or disprove: if §$(A §$sneq B) and §$(B §$sneq C)(,) then §$(A §$sneq C)(.)
          )
          §solution["transitivity_sneq"](
            §p(
              We disprove the statement by giving a counterexample. Define §$(A §$defeq §$set(§$symbol0), B §$defeq §$set(§$symbol1))(,) and §$(C §$defeq §$set(§$symbol0))(.) Then §$(A §$sneq B) (because §$(§$symbol0 §$in A) but §$(§$symbol0 §$notin B)), §$(B §$sneq C) (because §$(§$symbol1 §$in B) but §$(§$symbol1 §$notin C)), but §$(A §$seq C)(.)
            )
          )
        )

        §p(
          The definition of §r(sequal)(set equality) also justifies why we talk about §verbatim(§em(the) §r(empty set)) and not §verbatim(§em(an) §r(empty set)). The set of numbers that are both less than 12 and greater than 17, and the set of unicorns on the international space station, are precisely the same mathematical object.
        )

      )

      §hsection["subsection_subsets"](Subsets)(
        §p(
          We can think of §r(sequal)(set equality) as a very strict way of looking for similarity between two §rs(set). But there are more general ways in which §rs(set) can be related. It might be the case, for example, that one §r(set) contains all §rs(element) of another §r(set), but not necessarily the other way around. This relation is common enough that we give it a name:
        )

        §definition["subseteq"](Subset, Superset)(
          §set_math_id["subseteq", "subseteq"]
          §set_math_id["supseteq", "subseteq"]
          §set_math_id["nsubseteq", "subseteq"]
          §set_math_id["nsupseteq", "subseteq"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )§p(
            We say §$(A) is a §define(subset) of §$(B)(,) written as §$(A §$subseteq B)(,) if for all §$(x §$in A) we have §$(x §$in B)(.)
          )§p(
            Conversely, we say that §$(B) is a §define(superset) of §$(A)(,) written as §$(B §$supseteq A)(,) if §$(A §$subseteq B)(.)
          )§p(
            We further write §$(A §$nsubseteq B) if not §$(A §$subseteq B)(,) and §$(A §$nsupseteq B) if not §$(A §$supseteq B)(.)
          )
        )

        §p(
          Explore §cref(example_subseteq) for a bit. What do you expect to happen if both §rs(set) are §r(sequal)? What if one of them is §r(empty set)(empty)?
        )

        §div(slightlywide)(
          §example["example_subseteq"](Subsets and Supersets)(
            §captioned(
              §input["euler_diagrams/subseteq.html"]
            )(
              §p(
                Two §rs(set) and the §r(subset) and §r(superset) relations between them.
              )
            )
          )
        )

        §p(
          If you compare the definitions of §r(sequal)(set equality) and §rs(subset), you can see that the definition of §rs(subset) is essentially one direction of the §r(bi-implication) in the definition of §r(sequal)(set equality). In other words, two §rs(set) are §r(sequal) if they are both §rs(subset) and §rs(superset) of each other. Formally:
        )

        §observation["sequality_and_subsets"](
          §$(A §$seq B) if and only if §$(A §$subseteq B) and §$(A §$supseteq B)(.)
        )
        §proof["sequality_and_subsets"](
          §proof_as_exercise["sequality_and_subsets"](
            §proof_part(
              §verbatim(§$(A §$seq B §$implies A §$subseteq B) and §$(A §$supseteq B)):
            )(
              §p(
                Assume §$(A §$seq B)(.) We now show that §$(A §$subseteq B) and §$(A §$supseteq B)(.)
              )§p(
                Let §$(a §$in A)(,) then §$(a §$in B)(,) because §$(A §$seq B)(.) Thus, §$(A §$subseteq B)(.)
              )§p(
                Analogously, let §$(b §$in B)(,) then §$(b §$in A)(,) because §$(A §$seq B)(.) Thus, §$(A §$supseteq B)(.)
              )
            )
            §proof_part(
              §verbatim(§$(A §$subseteq B) and §$(A §$supseteq B §$implies A §$seq B)):
            )(
              §p(
                Assume that §$(A §$subseteq B) and §$(A §$supseteq B)(.) We now show that §$(A §$seq B)(.)
              )
              §proof_part(
                §verbatim(§$(a §$in A §$implies a §$in B)):
              )(
                Let §$(a §$in A)(,) then §$(a §$in B)(,) because §$(A §$subseteq B)(.)
              )
              §proof_part(
                §verbatim(§$(b §$in B §$implies b §$in A)):
              )(
                Let §$(b §$in B)(,) then §$(b §$in A)(,) because §$(A §$supseteq B)(.)
              )
            )
          )
        )

        §p(
          This alternate characterization offers yet another way of proving §r(sequal)(set equality).
        )

        §p(
          If you played around a bit with §cref(example_subseteq), you may have noticed that the §r(empty set) is a §r(subset) of every set. To understand why, we need to take a close look at how §rs(subset) are defined. The §r(subset)(definition) talks about §verbatim(all §$(x §$in A)), so what happens if §$(A §$seq §$set)(?) There exists no §$(x) such that §$(x §$in §$set)(,) so what does that mean for the §r(subset)(definition)?
        )§p(
          On an intuitive level, you can say that in order to show that some §r(set) is a §r(subset) of another, you need to show that a certain property holds for each of its §rs(member). As the §r(empty set) has no §rs(member), you do not need to show anything.
        )§p(
          More formally, the phrase §verbatim(for all §$(x §$in A) holds §i(bla)) is a shorthand for §verbatim(for all objects §$(x) holds that §$(x §$in A) implies §i(bla)). With that knowledge, we can formally prove that the §r(empty set) is a §r(subset) of every set:
        )

        §theorem["empty_set_subset_everything"](
          §p(Let §$(A) be a §r(set), then §$(§$set §$subseteq A)(.))
        )
        §proof["empty_set_subset_everything"](
          §p(
            Let §$(x) be an object. We need to show that §$(x §$in §$set) implies §$(x §$in A)(,) so assume that §$(x §$in §$set)(.)
          )§p(
            Because the §r(empty set) has no §rs(member), we know that §$(x §$notin §$set)(.) As we cannot have §$(x §$in §$set) and §$(x §$notin §$set) simultaneously, §$(x §$in A) holds by the §r(principle of explosion).
          )
        )

        §p(
          Whenever a statement of §r(universal quantification) holds because it is constrained to elements from the §r(empty set), we say that the statement holds §define(vacuously).
        )

        §exercise["vacuous_nontruth"](
          §p(
            Based on your knowledge about §r(negation)(negating) §rs(universal quantification), give a full picture of how statements like §verbatim(there exists §$(x §$in §$set) such that §i(bla)) work out.
          )
          §solution["vacuous_nontruth"](
            §p(
              Such a statement is always false; intuitively it is impossible to find a §r(witness) that is §r(in) the §r(empty set).
            )
            §p(
              §verbatim(There exists §$(x §$in §$set) such that §i(bla)) is §r(bi-implication)(equivalent) to its §r(double negation) §verbatim(it does not hold that there exists no §$(x §$in §$set) such that §i(bla)). This in turn is §r(bi-implication)(equivalent) to §verbatim(it does not hold that for all §$(x §$in §$set) §i(not bla)), which is the §r(negation) of a §r(vacuously) true statement, and thus false.
            )
          )
        )

        §p(
          The concept of §rs(subset) is ubiquitous in mathematics, so use the following exercises and theorems to familiarize yourself with it. They also present a good opportunity to practice your §r(deductive reasoning) skills.
        )

        §exercise["exercise_partial_subsets"](
          §p(
            Give §rs(set) §$(A)(,) §$(B)(,) and §$(C)(,) such that §$(A §$subseteq C) and §$(B §$subseteq C)(,) but §$(A §$nsubseteq B) and §$(B §$nsubseteq A)(.)
          )
          §solution["exercise_partial_subsets"](
            §p(
              Define §$(A §$defeq §$set(§$symbol0), B §$defeq §$set(§$symbol1))(,) and §$(C §$defeq §$set(§$symbol0)(§$symbol1))(.) Then §$(A §$subseteq C) and §$(B §$subseteq C)(,) but §$(A §$nsubseteq B) (because §$(§$symbol0 §$in A) but §$(§$symbol0 §$in B)) and §$(B §$nsubseteq A) (because §$(§$symbol1 §$in B) but §$(§$symbol1 §$in A)).
            )
          )
        )

        §theorem["subseteq_reflexivity"](Reflexivity of §$(§$subseteq[true]))(
          §p(
            Let §$(A) be a §r(set), then §$(A §$subseteq A)(.)
          )
        )
        §proof["subseteq_reflexivity"](
          §proof_as_exercise["subseteq_reflexivity"](
            §p(
              Let §$(A) be a §r(set), and let §$(a §$in A). Then §$(a §$in A), and thus §$(A §$subseteq A)(.)
            )
          )
        )

        §theorem["subseteq_transitivity"](Transitivity of §$(§$subseteq[true]))(
          §p(
            Let §$(A, B, C) be §rs(set). If §$(A §$subseteq B) and §$(B §$subseteq C)(,) then §$(A §$subseteq C)(.)
          )
        )
        §proof["subseteq_transitivity"](
          §proof_as_exercise["subseteq_transitivity"](
            §p(
              Let §$(A, B, C) be §rs(set). Assume that §$(A §$subseteq B) and §$(B §$subseteq C)(.)
            )§p(
              Let §$(a §$in A)(,) then
            )§fleqn(
              §$$align*(
                && a &§$in A
              )(
                §$implies {} && a &§$in B §$tag($A §$subseteq B$)
              )(
                §$implies {} && a &§$in C, §$tag($B §$subseteq C$)
              )
            )§p(
              and thus §$(A §$subseteq C)(.)
            )
          )
        )

        §exercise["subseteq_cyclic"](
          §p(
            Prove or disprove: there exist §rs(set) §$(A, B, C) such that §$(A §$subseteq B)(,) §$(B §$subseteq C)(,) and §$(C §$subseteq A)(.)
          )
          §solution["subseteq_cyclic"](
            §p(
              The statement holds. Define §$(A §$defeq §$set)(,) §$(B §$defeq §$set)(,) and §$(C §$defeq §$set)(.) Then §$(A §$subseteq B)(,) §$(B §$subseteq C)(,) and §$(C §$subseteq A) by §cref(subseteq_reflexivity).
            )§p(
              Bonus exercise: show that for all §rs(set) §$(A, B, C) we have that §$(A §$subseteq B)(,) §$(B §$subseteq C) and §$(C §$subseteq A) if and only if §$(A §$seq B) and §$(B §$seq C)(.)
            )
          )
        )

        §p(
          §Rs(subset) express that some §r(set) contains at least every §r(member) of another §r(set). Sometimes we want to express that a §r(set) also contains at least one further object:
        )

        §definition["subset"](Strict Subset, Strict Superset)(
          §set_math_id["subset", "subset"]
          §set_math_id["supset", "subset"]
          §set_math_id["nsubset", "subset"]
          §set_math_id["nsupset", "subset"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )§p(
            We say §$(A) is a §define(strict subset) of §$(B)(,) written as §$(A §$subset B)(,) if §$(A §$subseteq B) and §$(A §$sneq B)(.)
          )§p(
            Conversely, we say §$(A) is a §define(strict superset) of §$(B)(,) written as §$(A §$supset B)(,) if §$(A §$supseteq B) and §$(A §$sneq B)(.)
          )§p(
            We further write §$(A §$nsubset B) if not §$(A §$subset B)(,) and §$(A §$nsupset B) if not §$(A §$supset B)(.)
          )
        )

        §p(
          §Rs(strict subset) behave similar to (possibly non-strict) §rs(subset), but the following exercises also highlight some differences.
        )

        §theorem["subset_transitivity"](Transitivity of §$(§$subset[true]))(
          §p(
            Let §$(A, B, C) be §rs(set). If §$(A §$subset B) and §$(B §$subset C)(,) then §$(A §$subset C)(.)
          )
        )
        §proof["subset_transitivity"](
          §proof_as_exercise["subset_transitivity"](
            §p(
              Let §$(A, B, C) be §rs(set). Assume that §$(A §$subset B) and §$(B §$subset C)(.)
            )§p(
              As every §r(strict subset) of a §r(set) is also a (not necessarily strict) §r(subset), §cref(subseteq_transitivity) gives us that §$(A §$subseteq C)(.) It remains to show that §$(A §$sneq C)(.)
            )§p(
              Since §$(A §$sneq B) but every §r(member) of §$(A) is a §r(member) of §$(B) (both because §$(A §$subset B)), there exists some §$(x §$in B) with §$(x §$notin A)(.) Because §$(x §$in B) and §$(B §$subset C)(,) we know that §$(x §$in C). And since §$(x §$notin A)(,) we get that §$(A §$sneq C)(.)
            )
          )
        )

        §exercise["subset_antisymmetry"](
          §p(
            Let §$(A, B) be §rs(set). Prove or disprove: if §$(A §$subset B) and §$(B §$subset A)(,) then §$(A §$seq B)(.)
          )
          §solution["subset_antisymmetry"](
            §p(
              The statement holds. Its §r(premise) can never be fulfilled. We formally prove the statement by assuming the §r(premise) to hold, deriving a contradiction, and applying the §r(principle of explosion) to show the §r(conclusion).
            )§p(
              Assume that §$(A §$subset B) and §$(B §$subset A)(.) Then §$(a §$in A) implies §$(a §$in B) (because §$(A §$subset B)), and furthermore §$(b §$in B) implies §$(b §$in A) (because §$(B §$subset A)), that is, §$(A §$seq B)(.)
            )§p(
              By assumption we also have §$(A §$sneq B) as well however, a contradiction. By the §r(principle of explosion), we can follow that §$(A §$seq B)(,) and have thus proven the statement.
            )§p(
              We could have also ended the proof at the end of its second paragraph, as we have already proven the §r(conclusion) at that point. The third paragraph merely demonstrates how we can show anything from an impossible §r(premise).
            )
          )
        )

        §exercise["subset_cyclic"](
          §p(
            Prove or disprove: there exist §rs(set) §$(A, B, C) such that §$(A §$subset B)(,) §$(B §$subset C)(,) and §$(C §$subset A)(.)
          )
          §solution["subset_cyclic"](
            §p(
              The statement does not hold, so we prove its §r(negation). Let §$(A, B, C) be §rs(set), and suppose toward a contradiction that §$(A §$subset B)(,) §$(B §$subset C)(,) and §$(C §$subset A)(.)
            )§p(
              Because §$(A §$subset B)(,) there exists §$(x §$in B) such that §$(x §$notin A)(.) Then §$(x §$in C)(,) because §$(x §$in B) and §$(B §$subset C)(.) But then also §$(x §$in A)(,) because §$(x §$in C) and §$(C §$subset A)(,) a contradiction.
            )
          )
        )

      )

    )

    §hsection["combining_sets"](Combining Sets)(
      §p(
        When considering multiple §rs(set), some objects might be §r(in) exactly one of them, while others might be §r(in) multiple of them. Take, for example, the three §rs(set) of species of animals that can walk, swim, or fly respectively. We might be interested in the set of all species that can walk and swim but cannot fly. In this section, we introduce terminology for deriving such §rs(set) from other §rs(set).
      )

      §p(
        §cref(my_first_venn_diagram) visualizes the example in a §definex["venn_diagram"](Venn diagram)(
          §p(
            A §rdef(Venn diagram) visualizes all possible ways in which a number of §rs(set) can overlap:
          )
          §div(venn3_container centered)(
            §input["venn_diagrams/definition_venn.svg"]
          )
        ), a special type of §r(Euler diagram) that shows all possible ways in which some §rs(set) can overlap.
      )

      §figure["my_first_venn_diagram"](
        §captioned(
          §div{"style": "grid-column: 1; grid-row: 1"}(
            §input["venn_diagrams/first_venn.svg"]
          )
          §div(duck_container)()(
            §div(img_container)(
              <img src="./assets/images/duck.png">
            )
          )
        )(
          §p(
            A §r(Venn diagram) showing the §rs(set) of animal species that can walk (top), fly (left), and swim (right). Each region shows an icon of a species that belongs to it.
          )
        )
      )





      §p(
        So far, we have only denoted §rs(set) by explicitly enumerating their §rs(member), which does not help us when trying to define a §r(set) in terms of other §rs(set). For that reason, we introduce the §definex["set_builder_notation"](set builder notation)(
          §p(
            In §rdef(set builder notation), we define a §r(set) by giving a predicate that holds for exactly the §rs(member) of the §r(set):
            §$$(
              §$set_builder[1](x)(§$text($x §$in §$set(§$symbol0)(§$symbol1)(§$symbol2)$ and $x §$in §$set(§$symbol0)(§$symbol2)(§$symbol3)$)) §$seq §$set(§$symbol0)(§$symbol2).
            )
          )§p(
            Read the above example as §verbatim(the §r(set) that contains all §$(x) such that §$(x §$in §$set(§$symbol0)(§$symbol1)(§$symbol2)) and §$(x §$in §$set(§$symbol0)(§$symbol2)(§$symbol3))).
          )
        ), in which we specify a §r(set) by giving a §r(predicate) that is satisfied exactly by the §rs(member) of the §r(set) (read the vertical bar (§verbatim(§$(§$mid))) as §verbatim(such that)):
      )§p(
        §$(§$set_builder[1](x)(§$text($x §$in §$set(§$symbol0)(§$symbol1)(§$symbol2)$ and $x §$in §$set(§$symbol0)(§$symbol2)(§$symbol3)$)))(,) for example, is a complicated way of denoting the §r(set) §$(§$set(§$symbol0)(§$symbol2))(.)
      )§p(
        As this notation is more of a technicality than an interesting new concept, we shall not dwell on it any further.
      )

      §hsection["intersection_and_union"](Intersection and Union)(
        <svg xmlns="http://www.w3.org/2000/svg" width="0" height="0">
        	<defs>
        		<pattern id="pattern_striped" patternUnits="userSpaceOnUse" width="13.5" height="13.5" patternTransform="rotate(45)">
        			<line x1="0" y="0" x2="0" y2="13.5" stroke="#EB88ED" stroke-width="9" />
        		</pattern>
        	</defs>
        </svg>

        §p(
          We now define our terminology for the objects that occur in both of two §rs(set):
        )

        §definition["intersection"](Intersection)(
          §set_math_id["intersection", "intersection"]
          §p(
            Let §$(A, B) be §rs(set). The §define(intersection) of §$(A) and §$(B)(,) written as §$(A §$intersection B)(,) is the §r(set) of all objects which are §rs(element) of both §$(A) and §$(B)(:)

            §$$(
              A §$intersection B §$defeq §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)).
            )
          )
          §div(venn2_container centered)(
            §input["venn_diagrams/intersection.svg"]
          )
        )

        §div(slightlywide)(
          §example["example_intersection"](Intersection)(
            §input["euler_diagrams/intersection.html"]
          )
        )

        §p(
          If we swap the §r(conjunction) for a §r(disjunction) in the definition of the §r(intersection) of two §rs(set), we obtain another useful concept:
        )

        §definition["union"](Union)(
          §set_math_id["union", "union"]
          §p(
            Let §$(A, B) be §rs(set). The §define(union) of §$(A) and §$(B)(,) written as §$(A §$union B)(,) is the §r(set) of all objects which are §rs(element) of at least one of §$(A) or §$(B)(:)

            §$$(
              A §$union B §$defeq §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)).
            )
          )
          §div(venn2_container centered)(
            §input["venn_diagrams/union.svg"]
          )
        )

        §div(slightlywide)(
          §example["example_union"](Union)(
            §input["euler_diagrams/union.html"]
          )
        )

        §p(
          §R(intersection) and §r(union) are §definex["binary_operator"](binary operator)(binary operators)(binary operators)(
            §p(
              A §rdef(binary operator) combines exactly two objects into a new object.
            )
          ), that is, they combine exactly two §rs(set). If we wish to combine more than two §rs(set), we group the §rs(set) as pairs in parentheses and can then compute those pairs successively:
        )

        §p(
          §$$align*(
            & §$p[2](§$set(§$symbol0)(§$symbol1)(§$symbol2) §$intersection §$p[1](§$set(§$symbol1)(§$symbol3) §$highlight(§$union) §$set(§$symbol1)(§$symbol2)(§$symbol3))) §$union §$set
          )(
            §$seq {} & §$p[1](§$set(§$symbol0)(§$symbol1)(§$symbol2) §$highlight2(§$intersection) §$highlight(§$set(§$symbol1)(§$symbol2)(§$symbol3))) §$union §$set
          )(
            §$seq {} & §$highlight2(§$set(§$symbol1)(§$symbol2)) §$highlight3(§$union) §$set
          )(
            §$seq {} & §$highlight3(§$set(§$symbol1)(§$symbol2))
          )
        )

        §p(
          Computing such expressions is the bread-and-butter operation of set theory, just like addition and multiplication are for arithmetic. The next exercise gives you ample opportunities to practice, you can generate new expressions and solutions with the click of a button.
        )

        §exercise["practice_intersection_union_direct"](
          §p(
            Compute §span(practice_intersection_union_direct_text)()()
          )

          §solution["practice_intersection_union_direct"](
            §div(practice_intersection_union_direct_solution)()()
          )
          §p(
            §button(practice_intersection_union_direct_new)()(Generate new exercise)
          )
        )

        §p(
          Grouping these expressions with parentheses is necessary in general, because there are expressions for which the exact grouping makes a difference in the result:
        )

        §statement["intersection_union_parens"](
          §p(
            There exist §rs(set) §$(A, B, C) such that §$(§$p(A §$intersection B) §$union C §$sneq A §$intersection §$p(B §$union C))(.)
          )
        )

        §proof["intersection_union_parens"](
          §proof_as_exercise["intersection_union_parens"](
            §fleqn(
              §p(
                Define §$(A §$defeq §$set§ , B §$defeq §$set§ , C §$defeq §$set(§$symbol0))(.) Then §$$align*(
                  §$p(A §$intersection B) §$union C &§$seq §$p(§$set §$intersection §$set) §$union §$set(§$symbol0) §$tag(Definition $A, B, C$)
                )(
                  &§$seq §$set §$union §$set(§$symbol0) §$tag(Definition $§$intersection§ $)
                )(
                  &§$seq §$set(§$symbol0), §$tag(Definition $§$union§ $)
                ) but §$$align*(
                  A §$intersection §$p(B §$union C) &§$seq §$set §$intersection §$p(§$set §$union §$set(§$symbol0)) §$tag(Definition $A, B, C$)
                )(
                  &§$seq §$set §$intersection §$set(§$symbol0) §$tag(Definition $§$union§ $)
                )(
                  &§$seq §$set§ , §$tag(Definition $§$intersection§ $)
                ) and §$(§$set(§$symbol0) §$sneq §$set)(.)
              )
            )
          )
        )

        §p(
          The grouping does not affect the result when they are only §rs(intersection) or only §rs(union) involved.
        )

        §div(slightlywide)(
          §theorem["associative_intersection"](Associativity of §$(§$intersection[true]§ ))(
            §p(
              Let §$(A, B, C) be §rs(set). Then §$(§$p(A §$intersection B) §$intersection C §$seq A §$intersection §$p(B §$intersection C))(.)
            )
            §div(three_venns centered)(
              §div(venn3_container)(
                §input["venn_diagrams/intersection_3a.svg"]
              )
              §div(venn3_container)(
                §input["venn_diagrams/intersection_3b.svg"]
              )
              §div(venn3_container)(
                §input["venn_diagrams/intersection_3c.svg"]
              )
            )
          )
          §proof["associative_intersection"](
            §fleqn(
              §p(
                Let §$(A, B, C) be §rs(set). Then §$$align*(
                  &§$p(A §$intersection B) §$intersection C
                )(
                  §$seq {} & §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$intersection C §$tag(Definition $§$intersection§ $)
                )(
                  §$seq {} & §$set_builder[1](y)(§$text($y §$in §$set_builder(x)(§$text($x §$in A$ and $x §$in B$))$ and $y §$in C$)) §$tag(Definition $§$intersection§ $)
                )(
                  §$seq {} & §$set_builder(x)(§$text(($x §$in A$ and $x §$in B$) and $x §$in C$)) §$tag(§R(set builder notation))
                )(
                  §$seq {} & §$set_builder(x)(§$text($x §$in A$ and ($x §$in B$ and $x §$in C$))) §$tag(§r(associative conjunction)(Associativity) §r(conjunction))
                )(
                  §$seq {} & §$set_builder[1](y)(§$text($y §$in A$ and $y §$in §$set_builder(x)(§$text($x §$in B$ and $x §$in C$))$)) §$tag(§R(set builder notation))
                )(
                  §$seq {} & A §$intersection §$set_builder(x)(§$text($x §$in B$ and $x §$in C$)) §$tag(Definition $§$intersection§ $)
                )(
                  §$seq {} & A §$intersection §$p(B §$intersection C). §$tag(Definition $§$intersection§ $)
                )
              )
            )
          )
        )

        §div(slightlywide)(
          §theorem["associative_union"](Associativity of §$(§$union[true]§ ))(
            §p(
              Let §$(A, B, C) be §rs(set). Then §$(§$p(A §$union B) §$union C §$seq A §$union §$p(B §$union C))(.)
            )
            §div(three_venns centered)(
              §div(venn3_container)(
                §input["venn_diagrams/union_3a.svg"]
              )
              §div(venn3_container)(
                §input["venn_diagrams/union_3b.svg"]
              )
              §div(venn3_container)(
                §input["venn_diagrams/union_3c.svg"]
              )
            )
          )
          §proof["associative_union"](
            §proof_as_exercise["associative_union"](
              §fleqn(
                §p(
                  Let §$(A, B, C) be §rs(set). Then §$$align*(
                    &§$p(A §$union B) §$union C
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)) §$union C §$tag(Definition $§$union§ $)
                  )(
                    §$seq {} & §$set_builder[1](y)(§$text($y §$in §$set_builder(x)(§$text($x §$in A$ or $x §$in B$))$ or $y §$in C$)) §$tag(Definition $§$union§ $)
                  )(
                    §$seq {} & §$set_builder(x)(§$text(($x §$in A$ or $x §$in B$) or $x §$in C$)) §$tag(§R(set builder notation))
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ or ($x §$in B$ or $x §$in C$))) §$tag(§r(associative disjunction)(Associativity) §r(disjunction))
                  )(
                    §$seq {} & §$set_builder[1](y)(§$text($y §$in A$ or $y §$in §$set_builder(x)(§$text($x §$in B$ or $x §$in C$))$)) §$tag(§R(set builder notation))
                  )(
                    §$seq {} & A §$union §$set_builder(x)(§$text($x §$in B$ or $x §$in C$)) §$tag(Definition $§$union§ $)
                  )(
                    §$seq {} & A §$union §$p(B §$union C). §$tag(Definition $§$union§ $)
                  )
                )
              )
            )
          )
        )

        §p(
          We call operators for which the grouping makes no difference §define(associative), and we don't require explicit grouping via parentheses for §r(associative) operators, so it is fine to write, for example, §verbatim(§$(A §$union B §$union C)). In general, you must always provide parentheses with any §r(binary operator), unless the operator in question has been proven to be §r(associative).
        )

        §p(
          The proofs for §cref(associative_intersection) and §cref(associative_union) are very typical for proving properties about freshly defined concepts: you unfold the definition of the concept until you are only working with older concepts, you use their known properties to prove what you need, and finally you translate it back into the new terminology. In this particular case, §r(intersection) and §r(union) inherit the §r(associative conjunction)(associativity) of §r(conjunction) and §r(disjunction) respectively fairly directly. Using structurally similar proofs, we can show that they inherit §r(commutative conjunction)(commutativity) as well:
        )

        §theorem["commutative_intersection"](Commutativity of §$(§$intersection[true]§ ))(
          §p(
            Let §$(A, B) be §rs(set). Then §$(A §$intersection B §$seq B §$intersection A)(.)
          )
        )
        §proof["commutative_intersection"](
          §proof_as_exercise["commutative_intersection"](
            §fleqn(
              §p(
                Let §$(A, B) be §rs(set). Then §$$align*(
                  &A §$intersection B
                )(
                  §$seq {} & §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(Definition $§$intersection§ $)
                )(
                  §$seq {} & §$set_builder(x)(§$text($x §$in B$ and $x §$in A$)) §$tag(§r(commutative conjunction)(Commutativity) §r(conjunction))
                )(
                  §$seq {} & B §$intersection A §$tag(Definition $§$intersection§ $)
                )
              )
            )
          )
        )

        §theorem["commutative_union"](Commutativity of §$(§$union[true]§ ))(
          §p(
            Let §$(A, B) be §rs(set). Then §$(A §$union B §$seq B §$union A)(.)
          )
        )
        §proof["commutative_union"](
          §proof_as_exercise["commutative_union"](
            §fleqn(
              §p(
                Let §$(A, B) be §rs(set). Then §$$align*(
                  &A §$union B
                )(
                  §$seq {} & §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)) §$tag(Definition $§$union§ $)
                )(
                  §$seq {} & §$set_builder(x)(§$text($x §$in B$ or $x §$in A$)) §$tag(§r(commutative disjunction)(Commutativity) §r(disjunction))
                )(
                  §$seq {} & B §$union A §$tag(Definition $§$union§ $)
                )
              )
            )
          )
        )

        §p(
          Two further simple but useful observations are that §rs(intersection) never add elements, and §rs(union) never remove elements:
        )

        §theorem["intersection_nonincreasing"](
          §p(
            Let §$(A, B) be §rs(set). Then §$(A §$intersection B §$subseteq A)(.)
          )
        )
        §proof["intersection_nonincreasing"](
          §p(
            Let §$(A, B) be §rs(set), and let §$(x §$in A §$intersection B). Then also §$(x §$in A) by definition of §$(§$intersection)(,) and thus §$(A §$intersection B §$subseteq A)(.)
          )
        )

        §theorem["union_nondecreasing"](
          §p(
            Let §$(A, B) be §rs(set). Then §$(A §$subseteq A §$union B)(.)
          )
        )
        §proof["union_nondecreasing"](
          §proof_as_exercise["union_nondecreasing"](
            §p(
              Let §$(A, B) be §rs(set), and let §$(x §$in A). Then also §$(x §$in A §$union B) by definition of §$(§$union)(,) and thus §$(A §$subseteq A §$union B)(.)
            )
          )
        )

        §p(
          The following exercises give you some more opportunities to practice proofs like this.
        )

        §exercise["exercise_characterize_subseteq"](
          §p(
            Let §$(A, B) be §rs(set). Show that §$(A §$subseteq B) if and only if §$(A §$intersection B §$seq A)(.)
          )

          §solution["exercise_characterize_subseteq"](
            §fleqn(
              §p(
                Let §$(A, B) be §rs(set).
              )

              §proof_part(
                §verbatim(§$(A §$subseteq B §$implies A §$intersection B §$seq A)):
              )(
                §p(
                  Assume §$(A §$subseteq B)(.) Then §$$align*(
                    & A §$intersection B
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(Definition $§$intersection§ $)
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$)) §$tag($x §$in A §$implies x §$in B$)
                  )(
                    §$seq {} & A. §$tag(§R(set builder notation))
                  )
                )
              )§proof_part(
                §verbatim(§$(A §$nsubseteq B §$implies A §$intersection B §$sneq A)):
              )(
                §p(
                  Assume §$(A §$nsubseteq B)(.) Then there is §$(a §$in A) such that §$(a §$notin B)(.) Then §$$align*(
                    & a §$notin B
                  )(
                    §$implies {} & a §$notin §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(§R(conjunction))
                  )(
                    §$implies {} & a §$notin A §$intersection B §$tag(Definition $§$intersection§ $)
                  )(
                    §$implies {} & A §$sneq A §$intersection B. §$tag($a §$in A$, Definition $§$seq§ $)
                  )
                )
              )
            )
          )
        )

        §exercise["exercise_union_subseteq"](
          §p(
            Let §$(A, B, C) be §rs(set) with §$(A §$subseteq C) and §$(B §$subseteq C)(.) Show that §$(A §$union B §$subseteq C).
          )

          §solution["exercise_union_subseteq"](
            §p(
              Let §$(A, B, C) be §rs(set), and assume that §$(A §$subseteq C) and §$(B §$subseteq C)(.)
            )§p(
              Let §$(x §$in A §$union B)(.) We need to show that §$(x §$in C)(.) As §$(x §$in A §$union B)(,) we know that §$(x §$in A) or §$(x §$in B)(,) hence we can do a case distinction.
            )§cases(
              §case(§$(x §$in A))(
                If §$(x §$in A)(,) then, because §$(A §$subseteq C), we have that §$(x §$in C)(.)
              )
              §case(§$(x §$in B))(
                If §$(x §$in B)(,) then, because §$(B §$subseteq C), we have that §$(x §$in C)(.)
              )
            )
          )
        )

        §div(slightlywide)(
          §theorem["exercise_intersection_union_absorption"](Absorption of §$(§$intersection[true]) and §$(§$union[true]))(
            §p(
              Let §$(A, B) be §rs(set). Then
            )§ol(
              §li(
                §$(A §$intersection §$p(A §$union B) §$seq A)(,) and
              )§li(
                §$(A §$union §$p(A §$intersection B) §$seq A)(.)
              )
            )
          )
          §proof["exercise_intersection_union_absorption"](
            §fleqn(
              §p(
                Let §$(A, B) be §rs(set).
              )§ol(
                §li(
                  §proof_as_exercise["exercise_intersection_union_absorption_1"](
                    §p(
                      §$$align*(
                        & A §$intersection §$p(A §$union B)
                      )(
                        §$seq {} & A §$intersection §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)) §$tag(Definition $§$union§ $)
                      )(
                        §$seq {} & §$set_builder(y)(§$text($y §$in A$ and $y §$in §$set_builder(x)(§$text($x §$in A$ or $x §$in B$))$)) §$tag(Definition $§$intersection§ $)
                      )(
                        §$seq {} & §$set_builder(x)(§$text($x §$in A$ and ($x §$in A$ or $x §$in B$))) §$tag(§R(set builder notation))
                      )
                    )§p(
                      We now show that this set is §r(sequal) to §$(A)(,) that is, we show that an object is §r(in) this set if and only if it is §r(in) §$(A)(.)
                    )

                    §proof_part(
                      §verbatim(§$(x §$in A §$implies x §$in §$set_builder(x)(§$text($x §$in A$ and ($x §$in A$ or $x §$in B$))))):
                    )(
                      If §$(x §$in A)(,) then §$(§$set_builder(x)(§$text($x §$in A$ or $x §$in B$)))(,) and then §$(§$set_builder(x)(§$text($x §$in A$ and ($x §$in A$ or $x §$in B$))))(.)
                    )
                    §proof_part(
                      §verbatim(§$(x §$in A §$impliedby x §$in §$set_builder(x)(§$text($x §$in A$ and ($x §$in A$ or $x §$in B$))))):
                    )(
                      If §$(x §$in §$set_builder(x)(§$text($x §$in A$ and ($x §$in A$ or $x §$in B$))))(,) then in particular §$(x §$in A)(,) as otherwise the §r(conjunction) could not be true.
                    )
                  )
                )

                §li(
                  §proof_as_exercise["exercise_intersection_union_absorption_2"](
                    §p(
                      §$$align*(
                        & A §$union §$p(A §$intersection B)
                      )(
                        §$seq {} & A §$union §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(Definition $§$intersection§ $)
                      )(
                        §$seq {} & §$set_builder(y)(§$text($y §$in A$ or $y §$in §$set_builder(x)(§$text($x §$in A$ and $x §$in B$))$)) §$tag(Definition $§$union§ $)
                      )(
                        §$seq {} & §$set_builder(x)(§$text($x §$in A$ or ($x §$in A$ and $x §$in B$))) §$tag(§R(set builder notation))
                      )
                    )§p(
                      We now show that this set is §r(sequal) to §$(A)(,) that is, we show that an object is §r(in) this set if and only if it is §r(in) §$(A)(.)
                    )

                    §proof_part(
                      §verbatim(§$(x §$in A §$implies x §$in §$set_builder(x)(§$text($x §$in A$ or ($x §$in A$ and $x §$in B$))))):
                    )(
                      If §$(x §$in A)(,) then any §r(disjunction) involving §verbatim(§$(x §$in A)) is true, and thus, in particular, §$(§$set_builder(x)(§$text($x §$in A$ or ($x §$in A$ and $x §$in B$))))(.)
                    )
                    §proof_part(
                      §verbatim(§$(x §$notin A §$implies x §$notin §$set_builder(x)(§$text($x §$in A$ or ($x §$in A$ and $x §$in B$))))):
                    )(
                      If §$(x §$notin A)(,) then §verbatim(§$(x §$notin A) and §$(x §$in B)) is not true, and then also §$(x §$notin §$set_builder(x)(§$text($x §$in A$ or ($x §$in A$ and $x §$in B$))))(.)
                    )
                  )
                )
              )
            )
          )
        )

      )

      §hsection["section_set_difference"](Set Difference)(
        §p(
          Thinking back to the example of the §rs(set) of §cref(my_first_venn_diagram)(species of animals that eat plants and those that eat meat), consider the §r(set) of true herbivores, that is, the species that eat plants but no meat. Using only §r(intersection) and §r(union), it is not possible to describe that §r(set). We thus define a third §r(binary operator):
        )

        §definition["set_difference"](Set Difference)(
          §set_math_id["setminus", "set_difference"]
          §p(
            Let §$(A, B) be §rs(set). The §define(set difference) of §$(A) and §$(B)(,) §define(relative complement) of §$(B) in §$(A)(,) or simply §$(A) §define(without) §$(B)(,) written as §$(A §$setminus B)(,) is the §r(set) of all objects which are §rs(element) of §$(A) but not of §$(B)(:)

            §$$(
              A §$setminus B §$defeq §$set_builder(x)(§$text($x §$in A$ and $x §$notin B$)).
            )
          )
          §div(venn2_container centered)(
            §input["venn_diagrams/setminus.svg"]
          )
        )

        §div(slightlywide)(
          §example["example_set_difference"](Set Difference)(
            §input["euler_diagrams/setminus.html"]
          )
        )

        §exercise["practice_set_difference_direct"](
          §p(
            Compute §span(practice_set_difference_direct_text)()()
          )

          §solution["practice_set_difference_direct"](
            §div(practice_set_difference_direct_solution)()()
          )
          §p(
            §button(practice_set_difference_direct_new)()(Generate new exercise)
          )
        )

        §p(
          Equipped with the notions of §r(intersection), §r(union), and §r(set difference), we can describe all the possible ways in which multiple §rs(set) can relate to each other:
        )

        §exercise["exercise_arbitrary_venn"](
          §p(
            Give an expression that denotes exactly the highlighted areas of the §r(Venn diagram) below. You will need at least §span(exercise_arbitrary_venn_text)()() operators.
          )

          §div(venn3_container centered)(
            §input["venn_diagrams/exercise_arbitrary.svg"]
          )

          §solution["exercise_arbitrary_venn"](
            §div(exercise_arbitrary_venn_solution)()()
          )
          §p(
            §button(exercise_arbitrary_venn_new)()(Generate new exercise)
          )
        )

        TODO render terms with associativity

        §p(
          An immediate observation we can make general properties of the §r(set difference) operation is that removing elements from a §r(set) always results in a (not necessarily strict) §r(subset):
        )

        §theorem["set_difference_nonincreasing"](
          §p(
            Let §$(A) and §$(B) be §rs(set). Then §$(A §$setminus B §$subseteq A)(.)
          )
        )
        §proof["set_difference_nonincreasing"](
          §p(
            Let §$(A) and §$(B) be §rs(set), and let §$(x §$in A §$setminus B). Then also §$(x §$in A) by definition of §$(§$setminus)(,) and thus §$(A §$setminus B §$subseteq A)(.)
          )
        )

        §p(
          Unlike §r(intersection) and §r(union), §r(set difference) is sensitive to both the order of the two §rs(set) to be combined, and the grouping of multiple §rs(set difference).
        )

        §statement["set_difference_not_commutative"](
          §p(
            There exist §rs(set) §$(A, B) such that §$(A §$setminus B §$sneq B §$setminus A)(.)
          )

          §proof_as_exercise["set_difference_not_commutative"](
            §p(
              Define §$(A §$defeq §$set) and §$(B §$defeq §$set(§$symbol0))(.) Then §$$align*(
                A §$setminus B &§$seq §$set §$setminus §$set(§$symbol0)
              )(
                &§$seq §$set§ ,
              ) and §$$align*(
                B §$setminus A &§$seq §$set(§$symbol0) §$setminus §$set
              )(
                &§$seq §$set(§$symbol0),
              ) but §$(§$set §$sneq §$set(§$symbol0))(.)
            )
          )
        )

        §statement["set_difference_not_associative"](
          §p(
            There exist §rs(set) §$(A, B, C) such that §$(§$p(A §$setminus B) §$setminus C §$sneq A §$setminus §$p(B §$setminus C))(.)
          )

          §proof_as_exercise["set_difference_not_associative"](
            §p(
              Define §$(A §$defeq §$set(§$symbol0), B §$defeq §$set)(,) and §$(C §$defeq §$set(§$symbol0))(.) Then §$$align*(
                §$p(A §$setminus B) §$setminus C &§$seq §$p[1](§$set(§$symbol0) §$setminus §$set) §$setminus §$set(§$symbol0)
              )(
                &§$seq §$set(§$symbol0) §$setminus §$set(§$symbol0)
              )(
                &§$seq §$set§ ,
              ) and §$$align*(
                A §$setminus §$p(B §$setminus C) &§$seq §$set(§$symbol0) §$setminus §$p[1](§$set §$setminus §$set(§$symbol0))
              )(
                &§$seq §$set(§$symbol0) §$setminus §$set
              )(
                &§$seq §$set(§$symbol0),
              ) but §$(§$set §$sneq §$set(§$symbol0))(.)
            )
          )
        )

        §p(
          When computing §rs(intersection) by hand, a helpful technique is to write down one of the §rs(set) and to then cross out the §rs(element) that do not occur in the other §r(set). An example: §$$(
            §$set(§$symbol0)(§$symbol1)(§$symbol3)(§$symbol4) §$intersection §$set(§$symbol0)(§$symbol2)(§$symbol3) §$seq §$set(§$symbol0)(§$cancel_symbol(§$symbol1))(§$symbol3)(§$cancel_symbol(§$symbol4)) §$seq §$set(§$symbol0)(§$symbol3).
          )

          We can prove that this technique always yields the correct result — take a moment to think through how the §cref(intersection_via_set_difference)(following theorem) relates to the technique:
        )

        §theorem["intersection_via_set_difference"](
          §p(
            Let §$(A) and §$(B) be §rs(set). Then §$(A §$intersection B §$seq A §$setminus §$p[1](A §$setminus B))(.)
          )
        )
        §proof["intersection_via_set_difference"](
          §proof_as_exercise["intersection_via_set_difference"](
            §p(
              Let §$(A) and §$(B) be §rs(set).
            )

            §proof_part(
              §verbatim(§$(A §$intersection B §$subseteq A §$setminus §$p[1](A §$setminus B))):
            )(
              §p(
                Let §$(x §$in A §$intersection B)(.) Then §$(x §$in B)(,) and thus §$(x §$notin A §$setminus B)(.) Since §$(x §$in A) (because §$(x §$in A §$intersection B)) and §$(x §$notin A §$setminus B)(,) we have that §$(x §$in A §$setminus §$p[1](A §$setminus B)) (by definition of §$(§$setminus)).
              )
            )
            §proof_part(
              §verbatim(§$(A §$intersection B §$supseteq A §$setminus §$p[1](A §$setminus B))):
            )(
              §p(
                Let §$(x §$in A §$setminus §$p[1](A §$setminus B))(.) Then §$(x §$in A) by §cref(set_difference_nonincreasing), so it remains to show that §$(x §$in B)(.)
              )§p(
                Suppose toward a contradiction that §$(x §$notin B)(.) Then §$(x §$in A §$setminus B)(,) and thus §$(x §$notin A §$setminus §$p[1](A §$setminus B))(,) contradicting our initial assumption that §$(x §$in A §$setminus §$p[1](A §$setminus B))(.)
              )
            )
          )
        )

        §p(
          We conclude the section with a few exercises on §r(set difference).
        )

        §exercise["exercise_set_difference0"](
          §p(
            Let §$(A, B, C) be §rs(set). Prove that if §$(A §$subset B)(,) then §$(C §$setminus B §$subset C §$setminus A)(.)
          )

          §solution["exercise_set_difference0"](
            §p(
              bla
            )
          )
        )

        §exercise["exercise_set_difference1"](
          §p(
            Let §$(A, B, C) be §rs(set). Prove that §$(B §$setminus A §$subseteq C) if and only if §$(B §$setminus C §$subseteq A)(.)
          )
        )

        §exercise["exercise_set_difference2"](
          §ol(
            §li(
              Let §$(A, B, C) be §rs(set). Prove that §$(C §$setminus §$p(B §$setminus A) §$seq §$p(C §$intersection A) §$union §$p(C §$setminus B))(.)
            )§li(
              How does this relate to §cref(intersection_via_set_difference)?
            )
          )
        )

















      )







    )

    §hsection["sets_of_sets"](Sets of Sets)(
      §p(
        TODO different intro With a solid understanding of the basic §rs(predicate) of set theory — §r(member)(membership), §r(sequal)(equality), and being a (§r(strict subset)(strict)) §r(subset) — under our belt, we can now examine what makes §rs(set) so powerful.
      )§p(
        A §r(set) can contain arbitrary mathematical objects. A §r(set) is a mathematical object itself. See where this is going? §Rs(set) can contain other §rs(set)!
      )§p(
        We can have nested §rs(set) such as §$(§$set[2](§$set(§$symbol0)(§$symbol1))(§$set(§$symbol0)(§$symbol2))(§$symbol3)), and our §rs(predicate) work just as before: §$$align*(
          §$highlight(§$set(§$symbol0)(§$symbol2)) &§$in §$set[2](§$set(§$symbol0)(§$symbol1))(§$highlight(§$set(§$symbol0)(§$symbol2)))(§$symbol3) §$text(, and)
        )(
          §$set[2](§$highlight2(§$set(§$symbol0)(§$symbol1)))(§$highlight3_direct(§$symbol3)) &§$subseteq §$set[2](§$highlight2(§$set(§$symbol0)(§$symbol1)))(§$set(§$symbol0)(§$symbol2))(§$highlight3_direct(§$symbol3)).
        )
      )§p(
        Always stay mindful of the difference between the §rs(member) of a §r(set) and the §rs(member) of the §rs(member) of a §r(set): §$(§$symbol0 §$notin §$set[2](§$set(§$symbol0)(§$symbol1))(§$set(§$symbol0)(§$symbol2))(§$symbol3))(,) even though §$(§$symbol0) is an §r(element) of some §rs(member) of §$(§$set[2](§$set(§$symbol0)(§$symbol1))(§$set(§$symbol0)(§$symbol2))(§$symbol3))(. )
      )§p(
        Another common source of mistakes is the distinction between an object and the §r(set) that contains exactly that object but nothing else. For all §rs(set) §$(X) we have that §$(§$set(X) §$sneq X)(,) because §$(X §$in §$set(X)) but §$(X §$notin X), as no §r(set) can be a §r(member) of itself. In particular, §$(§$set §$sneq §$set(§$set))(.) The §r(empty set) has no §rs(member), whereas §$(§$set(§$set)) has exactly one §r(member), namely the §r(empty set).
      )

      §exercise["nested_sets_predicates"](
        §p(
          Define §$(A §$defeq §$set(§$symbol0))(.) For each of the following subexercises, give a §r(set) §$(B) such that:
        )§ol(
          §li(§$(A §$notin B) and §$(A §$nsubseteq B)(.))
          §li(§$(A §$in B) and §$(A §$nsubseteq B)(.))
          §li(§$(A §$notin B) and §$(A §$subseteq B)(.))
          §li(§$(A §$in B) and §$(A §$subseteq B)(.))
        )

        §solution["nested_sets_predicates"](
          §ol(
            §li(
              §$(B §$defeq §$set)(.)
            )
            §li(
              §$(B §$defeq §$set[1](§$set(§$symbol0)))(.)
            )
            §li(
              §$(B §$defeq §$set(§$symbol0))(.)
            )
            §li(
              §$(B §$defeq §$set[1](§$symbol0)(§$set(§$symbol0)))(.)
            )
          )
        )
      )

      §p(
        Because we can nest §rs(set) arbitrarily deeply, we can represent arbitrarily complex mathematic concepts through §rs(set). Sometimes we do so explicitly by defining things in terms of §rs(set), sometimes we will simply assume implicitly that it would be possible to express concepts in terms of §rs(set). We have been using icons such as §$(§$symbol0§ , §$symbol1), and §$(§$symbol2) as mathematic objects for example, but since their only interesting property is how they behave in terms of §r(equal)(equality), we might as well have been using the §rs(set) §$(§$set§ , §$set(§$set))(,) and §$(§$set(§$set(§$set)))(.) Using symbols is more readable, but ultimately not necessary from a purely mathematic standpoint (and expressing everything in terms of pure sets is indeed how more formal approaches to set theory eliminate the problem of having to define objects before being able to define sets).
      )

      §hsection["section_powerset"](Power Sets)(
        §p(
          One particular kind of §r(set) of §rs(set) that we will encounter repeatedly throughout this book arises from the following question: Given some §r(set) §$(X), which §rs(set) are there that contain no objects but those from §$(X) (although not necessarily all of them)? This is in fact the same as asking for the §r(set) of §rs(subset) of §$(X) — take a moment to think through why that is. It is this viewpoint we use for our proper definition:
        )

        §definition["powerset"](Power Set)(
          §set_math_id["powerset", "powerset"]

          §p(
            Let §$(X) be a §r(set). The §define(power set) of §$(X)(,) written as §$(§$powerset(X))(,) is the §r(set) of all §rs(subset) of §$(X)(.)
          )
        )

        §div(slightlywide)(
          §example["example_powerset"](Power Set)(
            §input["euler_diagrams/powerset.html"]
          )
        )

        §p(
          Notice how §verbatim(§$(A §$subseteq U)) and §verbatim(§$(A §$in §$powerset(U))) mean the same thing.
        )§p(
          The definition of §rs(power set) is not particularly complicated, but the §r(power set) of the §r(empty set) feels slightly unintuitive to many learners at a first glance. Think through the following two exercises, and you should be fine.
        )

        §exercise["exercise_powerset_at_least"](
          §p(
            Find the mistake in the following claim: Because the §r(empty set) is a §r(subset) of every §r(set) (§cref(empty_set_subset_everything)) and every §r(set) is a §r(subset) of itself (§cref(subseteq_reflexivity)), §$(§$powerset(X)) must contain at least two §rs(element) for all §rs(set) §$(X)(.)
          )

          §solution["exercise_powerset_at_least"](
            §p(
              The argument ignores that the §r(empty set) and the §r(set) itself could be one and the same. And indeed, §$(§$powerset(§$set) §$seq §$set(§$set))(,) a §r(set) which only contains a single §r(element).
            )
          )
        )

        §exercise["exercise_powers_of_empty"](
          §p(
            Compute §$(§$powerset[2](§$powerset[1](§$powerset(§$set)))).
          )
          §solution["exercise_powers_of_empty"](
            §$$align*(
              §$powerset[2](§$powerset[1](§$powerset(§$set))) &§$seq §$powerset[2](§$powerset[1](§$set(§$set)))
            )(
              &§$seq §$powerset[2](§$set[1](§$set§ , §$set(§$set)))
            )(
              &§$seq §$set[2](§$set§ , §$set(§$set), §$set[1](§$set(§$set)), §$set[1](§$set§ , §$set(§$set)))
            )
          )
        )

        §p(
          bla
        )

        §theorem["equal_powersets_equal_sets"](
          §p(
            Let §$(A, B) be §rs(set). If §$(§$powerset(A) §$seq §$powerset(B))(,) then §$(A §$seq B)(.)
          )
        )
        §proof["equal_powersets_equal_sets"](
          §p(
            We do a proof by contraposition, that is, we show that if §$(A §$sneq B)(,) then §$(§$powerset(A) §$seq §$powerset(B))(.) To that end, let §$(A, B) be §rs(set) with §$(A §$sneq B)(.)
          )§p(
            Without loss of generality, there is §$(a §$in A) such that §$(a §$notin B) (otherwise switch the roles of §$(A) and §$(B)). Then §$(§$set(a) §$in §$powerset(A)) (because §$(§$set(a) §$subseteq A)) but §$(§$set(a) §$notin §$powerset(B)) (because §$(§$set(a) §$nsubseteq B)), and thus §$(§$powerset(A) §$sneq §$powerset(B))(.)
          )
        )

        §p(
          The proof of §cref(equal_powersets_equal_sets) contains the handy phrase §verbatim(without loss of generality), which indicates that only one of several distinct cases will be presented, because the other cases work in a similar way and can be handled through simple modifications to the presented argument. In this example, it is clearly not always true that §$(A) has a §r(member) that is not §r(in) §$(B)(,) as §$(A) could be a §r(strict subset) of §$(B)(.) But in that case, simply renaming §$(A) to §verbatim(§$(B)) and vice versa correctly finishes the proof.
        )§p(
          Quickly jotting down a §verbatim(without loss of generality) (or §verbatim(w.l.o.g.) for the particularly time-pressed mathematician) can often lead to overlooking crucial corner cases, leading to faulty proofs. Whenever you feel tempted to wlog your way out of a lengthy proof, ask yourself whether you can describe the necessary changes to cover all cases in one sentence. If yes, simply add that sentence to your proof. And if no, then you do not get to drop those convenient four words.
        )

      )

    )

    §hsection["conclusion_sets"](Conclusion)(
      §p(
        This concludes our first foray into set theory. Almost all of modern mathematics builds upon the notion of §rs(set), with its predicates of §r(member)(membership), §r(sequal)(equality), and §rs(subset), and the operations of §r(intersection), §r(union), §r(set difference), and §r(power set).
      )§p(
        By now, you should be familiar with all of them, having both developed good intuition for them, and being able to define them precisely and work with those definitions. The proofs in this chapter rarely required a brilliant idea, but rather demonstrated the basic workflow of breaking down definitions and letting the structure of the statements in question guide their proofs. This alone will get you quite far, a significant part of mathematics is solid, unexciting craftsmanship. It might not be glamorous, but it yields good results.
      )§p(
        Throughout the examples and exercises of this chapter, all specific §rs(set) contained finitely many §rs(element). The definition of §rs(set) does not require this, it is perfectly fine for a §r(set) to contain infinitely many objects. All our proofs work perfectly fine for infinite §rs(set). Infinite §rs(set) come with their own challenges however, starting with the simple question of how to even define an infinitely large object through a finite mathematic expression. The answers to that and several other problems are what we will cover in the §cref(chapter_induction)(next chapter).
      )
    )

    §hsection["exercises_sets"](Exercises)(
      §p(
        This section contains a collection of exercises that touch upon all definitions of this chapter. Some introduce new but related definitions, so make sure to read through all the exercises even if you do not intend to solve all of them. Unlike the exercises throughout the chapter body, these exercises come without solutions. Write your own instead, and try to get feedback on them.
      )

      §exercise["exercise_cardinality_constraints"](
        §ol(
          §li(
            §p(
              Give §rs(set) §$(A, B, C) such that all of the following conditions are satisfied simultaneously:
            )§ol(
              §li(§$(A) has exactly five §rs(element),)
              §li(§$(B) has exactly three §rs(element),)
              §li(§$(C) has at least as many §rs(element) as §$(A §$setminus B),)
              §li(§$(A §$union B) has exactly seven §rs(element),)
              §li(§$(B §$intersection C) has exactly two §rs(element), and)
              §li(§$(A §$setminus C) has exactly three §rs(element).)
            )
          )§li(
            §p(
              Give §rs(set) §$(D, E, F) such that all of the following conditions are satisfied simultaneously:
            )§ol(
              §li(§$(D §$subset E)(,))
              §li(§$(§$powerset(D) §$intersection F) has exactly two §rs(element),)
              §li(§$(E §$setminus F) has exactly two §rs(element), and)
              §li(§$(F §$in D).)
            )
          )
        )
      )

      §exercise["exercise_sets_solve"](
        §ol(
          §li(
            Find a §r(set) §$(X) such that §$(§$p(X §$setminus §$set(0)(2)) §$intersection §$p(X §$union §$set(0)(1)) §$seq §$set(0)(2) §$setminus X)(.) Justify your answer by giving the step-by-step computation of the expressions.
          )§li(
            Prove that your answer is the only solution. If you do not know how to prove this, think about it until you do. You will be learning something more than just following instructions that way.
          )§li(
            Invent your own exercises of this kind: one with exactly one solution, one with exactly two solutions, one with infinitely many solutions, and one with no solutions.
          )
        )
      )

      §theorem["subset_is_subseteq"](
        §p(
          Let §$(A, B) be §rs(set). If §$(A §$subset B)(,) then §$(A §$subseteq B)(.)
        )
      )
      §exercise["exercise_subset_is_subseteq"](
        §p(
          Prove §cref(subset_is_subseteq).
        )
      )

      §theorem["subset_subseteq_transitive"](
        §p(
          Let §$(A, B, C) be §rs(set).
        )§ol(
          §li(
            If §$(A §$subseteq B) and §$(B §$subset C)(,) then §$(A §$subset C)(.)
          )§li(
            If §$(A §$subset B) and §$(B §$subseteq C)(,) then §$(A §$subset C)(.)
          )
        )
      )
      §exercise["exercise_subset_subseteq_transitive"](
        §p(
          Prove §cref(subset_subseteq_transitive).
        )
      )

      §exercise["exercise_set_operations_extremes"](
        §p(
          Let §$(U) be a §r(set), and let §$(A §$subseteq U). For each of the following equations, give a §r(set) §$(B) that satisfies the equation, or prove that no such §$(B) exists.
        )

        §ol(
          §li(
            §$(A §$intersection B §$seq U)(,)
          )
          §li(
            §$(A §$intersection B §$seq A)(,)
          )
          §li(
            §$(A §$intersection B §$seq §$set)(,)
          )
          §li(
            §$(A §$union B §$seq U)(,)
          )
          §li(
            §$(A §$union B §$seq A)(,)
          )
          §li(
            §$(A §$union B §$seq §$set)(,)
          )
          §li(
            §$(A §$setminus B §$seq U)(,)
          )
          §li(
            §$(A §$setminus B §$seq A)(,)
          )
          §li(
            §$(A §$setminus B §$seq §$set)(.)
          )
        )

        §p(
          Keep in mind that §$(U) and §$(A) are §r(universal quantification)(universally quantified), so it is not sufficient to give a §r(set) §$(B) that only works for special choices of §$(U) and §$(A)(.) You can however define §$(B) in terms of §$(U) and §$(A)(,) for example, §verbatim(Define §$(B §$defeq U §$setminus A)).
        )
      )

      §theorem["distributivity_intersection_union"](Distributivity of §$(§$intersection[true]) and §$(§$union[true]))(
        §p(
          Let §$(A, B, C) be §rs(set). Then
        )

        §ol(
          §li(
            §$(A §$intersection §$p(B §$union C) §$seq §$p(A §$union B) §$intersection §$p(A §$union C))(,) and
          )§li(
            §$(A §$union §$p(B §$intersection C) §$seq §$p(A §$intersection B) §$union §$p(A §$intersection C))(.)
          )
        )
      )

      §exercise["exercise_distributivity_intersection_union"](
        §p(
          Prove §cref(distributivity_intersection_union).
        )
      )

      §exercise["exercise_set_difference3"](
        §p(
          Let §$(A, B, C) be §rs(set). Prove that §$(§$p(B §$setminus A) §$union C §$seq §$p(B §$union C) §$setminus §$p(A §$setminus C))(.)
        )
      )

      §exercise["exercise_powerset_lift"](
        §p(
          Let §$(A, B) be §rs(set). Prove or disprove:
        )
        §ol(
          §li(
            §$(§$powerset(A) §$union §$powerset(B) §$seq §$powerset(A §$union B))(,)
          )§li(
            §$(§$powerset(A) §$intersection §$powerset(B) §$seq §$powerset(A §$intersection B))(.)
          )
        )
      )

      §definition["symmetric_difference"](Symmetric Difference)(
        §set_math_id["symdif", "symmetric_difference"]
        §p(
          Let §$(A, B) be §rs(set). The §define(symmetric difference) of §$(A) and §$(B)(,) written as §$(A §$symdif B)(,) is the §r(set) of all objects which are §rs(element) of exactly one of §$(A) or §$(B)(:)

          §$$(
            A §$symdif B §$defeq §$p(A §$setminus B) §$union §$p(B §$setminus A).
          )
        )
        §div(venn2_container centered)(
          §input["venn_diagrams/symdif.svg"]
        )
      )

      §exercise["exercise_symdif_compute"](
        §p(
          Compute §$(§$set(0)(2)(3) §$symdif §$p[2](§$p[1](§$set(0)(2)(3) §$symdif §$set(0)(4)) §$symdif §$set(1)(3)(4))) step by step. If you did everything correctly, the final result should be §$(§$set(0)(1)(3))(.)
        )
      )

      §theorem["commutative_symdif"](Commutativity of §$(§$symdif[true]§ ))(
        §p(
          Let §$(A, B) be §rs(set). Then §$(A §$symdif B §$seq B §$symdif A)(.)
        )
      )
      §exercise["exercise_commutative_symdif"](
        §p(
          Prove §cref(commutative_symdif).
        )
      )

      §exercise["exercise_symdif_venn"](
        §p(
          Draw a §r(Venn diagram) of three §rs(set) §$(A, B, C)(,) and highlight the areas corresponding to §$(§$p(A §$symdif B) §$symdif C)(.)
        )
      )

      §theorem["associative_symdif"](Associativity of §$(§$symdif[true]§ ))(
        §p(
          Let §$(A, B, C) be §rs(set). Then §$(§$p(A §$symdif B) §$symdif C §$seq A §$symdif §$p(B §$symdif C))(.)
        )
      )
      §exercise["exercise_associative_symdif"](
        §p(
          Prove §cref(associative_symdif).
        )
      )

      §theorem["characterization_symdif"](
        §p(
          Let §$(A, B) be §rs(set). Then §$(A §$symdif B §$seq §$p(A §$union B) §$setminus §$p(A §$intersection B))(.)
        )
      )
      §exercise["exercise_characterization_symdif"](
        §p(
          Prove §cref(characterization_symdif).
        )
      )

    )

    §chapternav

    - detailed set builder notation?

  )
)
