§template(
  <title>Naïve Set Theory — Introduction to Mathematics</title>

  <link rel="stylesheet" href="./assets/sets.css">
  <script defer src="./assets/katex.min.js"></script/>

  <script defer src="./assets/accessibility.js" type="module"></script>
  <script defer src="./assets/animation.js" type="module"></script>
  <script defer src="./assets/geometry.js" type="module"></script>
  <script defer src="./assets/bitvec.js" type="module"></script>
  <script defer src="./assets/svg.js" type="module"></script>
  <script defer src="./assets/euler_diagrams.js" type="module"></script>

  <style>
    §powerset_colors
  </style>
)(
  §hsection["chapter_sets"](Naïve Set Theory)(
    §p(
      In the §cref(chapter_deductive_reasoning)(previous chapter) we examined how to formulate, prove, and disprove statements. The example statements we looked at talked about numbers and squirrel, but the principles we examined apply regardless of which objects the statements talk about. In this chapter, we examine a class of objects that is so powerful that we can express everything from numbers to computers to proofs themselves in it. This class of objects will provide the foundation for everything we will study throughout this book.
    )§p(
      Such a universal domain will allow us to apply very general concepts to arbitrarily specific situations. And yet you will find that the objects our statements will talk about are in themselves very simple. Striking that balance between simplicity and universality of foundational objects was arguably one of the key achievements of the 20th century: the development of §em(set theory).
    )

    §hsection["section_sets"](Sets)(
      §p(
        When attempting to define the foundations of mathematics, you run into a chicken-egg problem: Any definition needs to make use of mathematical concepts, so in particular the definition of the foundational objects also requires prior definitions. But then, it clearly is not foundational.
      )§p(
        While there are sophisticated ways of avoiding this problem, they require a good understanding of mathematics to begin with. So we instead follow the traditional approach in teaching: our very first definition will be slightly informal, and we will simply pretend that it was sufficiently precise. Hence the §verbatim(naïve) in the chapter title §verbatim(naïve)(set)(theory).
      )§p(
        In particular, we will talk about mathematical §verbatim(objects), without specifically stating what those are. For our purposes, we require that an object is §r(equal) to itself but not to anything else. The number §$(17)(,) for example, is a mathematical object.
      )§p(
        Furthermore, every object must be §verbatim(well-defined), that is, it must always be clear which object we are talking about. For example, §verbatim(the)(most important composer of the 18th)(century) is not well-defined; whether the most important composer of the 18th century is §r(equal) to §link(Johann Sebastian Bach)(https://en.wikipedia.org/wiki/Johann_Sebastian_Bach) is a matter of personal opinion, not of mathematical reasoning.
      )§p(
        In examples, we will use squirrel-related §side(iconography)(§cref(attribution_squirrelicons)(Attribution).) for our mathematical objects: §$(§$symbol0§ , §$symbol1§ , §$symbol2§ , §$symbol3)(,) and §$(§$symbol4)(.) We know that §$(§$symbol0 §$eq §$symbol0§ , §$symbol0 §$neq §$symbol1)(,) and so on, and these are the only properties we ascribe to those symbols.
      )§p(
        With that out of the way, it is time to look at the one definition upon which everything else in this book will build:
      )

      §definition["set"](Set)(
        §set_math_id["set", "set"]
        §p(
          A §define(set) is a collection of objects, characterized solely by which objects belong to it and which objects do not.
        )§p(
          We denote a §r(set) by listing its objects within curly braces, separated by commas, for example: §$(§$set(§$symbol0)(§$symbol1)(§$symbol2))(.)
        )§p(
          The §define(empty set) §$(§$set()) — the collection that contains no objects at all — is also written as §$(§$define_notation(§$set))(.)
        )
      )

      §p(
        Because a §r(set) is characterized by which objects belong to it, §$(§$set(§$symbol0)(§$symbol1)) and §$(§$set(§$symbol1)(§$symbol0)) are two different ways of denoting the same §r(set). Informally speaking, §rs(set) ignore the order of their objects. Furthermore, §$(§$set(§$symbol0)(§$symbol1)(§$symbol0)) and §$(§$set(§$symbol0)(§$symbol1)) also denote the same §r(set), you could say that §rs(set) ignore duplicates. All three expressions are simply different ways of denoting the unique mathematical object characterized by the fact that §$(§$symbol0) and §$(§$symbol1) belong to it, but nothing else does.
      )§p(
        After the build-up about the foundational concept that is able to express anything you could possibly dream up, the notion of §rs(set) might initially be a bit of a letdown. We will get to the reasons for why §rs(set) are a very powerful concept soon enough, but first, we define and inspect some elementary terminology and notation.
      )

      §definition["set_membership"](Set Membership)(
        §set_math_id["in", "set_membership"]
        §set_math_id["notin", "set_membership"]
        §p(
          To express that an object §$(x) occurs in a §r(set) §$(X)(,) we write §$(x §$define_notation(§$in) X)(,) and we say that §verbatim(§$(x))(is an §define(element) of)(§$(X)), §verbatim(§$(x))(is a §define(member) of)(§$(X)), or simply that §verbatim(§$(x))(§define(in))(§$(X)).
        )§p(
          If not §$(x §$in X)(,) we write §$(x §$define_notation(§$notin) X)(.)
        )
      )

      §example["example_set_membership"](
        §$(§$symbol0 §$in §$set(§$symbol0)(§$symbol1))(,) §$(§$symbol1 §$in §$set(§$symbol0)(§$symbol1))(,) and §$(§$symbol2 §$notin §$set(§$symbol0)(§$symbol1))(.)
      )

      §p(
        We can visualize §rs(member)(set membership) by drawing §rs(set) as blobs that enclose their §rs(element). §cref(example_euler_diagram) demonstrates such an §definex["euler_diagram"](Euler diagram)(
          §p(
            An §rdef(Euler diagram) visualizes §rs(member)(set membership) by drawing §rs(set) as blobs that enclose their §rs(element).
          )
          §input["euler_diagrams/vanilla_no_controls.html"]
        ). Note how the idea of a §r(set) containing §rs(element) multiple times or in a particular order cannot even be expressed in these §side(depictions)(Once the universe of objects under consideration has been laid out.), making §rs(Euler diagram) a more faithful representations of §rs(set) than our written notation.
      )

      §example["example_euler_diagram", "slightlywide"](Euler Diagram)(
        §captioned(
          §input["euler_diagrams/vanilla.html"]
        )(
          §p(An interactive §r(Euler diagram) showing two §rs(set). Toggle the buttons to change the depicted §rs(set).)
        )
      )

      §hsection["subsection_set_equality"](Set Equality)(
        §p(
          Based on the notion of §r(member)(set membership), we can define precisely when two §rs(set) are considered equal.
        )

        §definition["set_eq"](Set Equality)(
          §set_math_id["seq", "set_eq"]
          §set_math_id["sneq", "set_eq"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )
          §p(
            We say §$(A) and §$(B) are §define["", "seq"](equal)(equal), written as §$(A §$define_notation(§$seq) B)(,) if for each §$(x) holds that §$(x §$in A) if and only if §$(x §$in B)(.)
          )§p(
             If not §$(A §$seq B)(,) we write §$(A §$define_notation(§$sneq) B)(.)
          )
        )

        §p(
          Take a moment to consider some equivalent formulations for the §verbatim(if)(and only)(if) in §cref(set_eq):
        )
        §ul(
          §li(§$(A §$seq B) if every §$(x §$in A) is §r(in) §$(B) and every §$(x §$in B) is §r(in) §$(A)(.))
          §li(§$(A §$seq B) if every §$(x §$in A) is §r(in) §$(B) and every §$(x §$notin A) is not §r(in) §$(B)(.))
          §li(§$(A §$seq B) if every §$(x) is either §r(in) both §$(A) and §$(B) or §r(in) neither.)
        )
        §p(
          All of these ways of looking at §r(seq)(set equality) can come in handy when trying to prove that two complex descriptions of §rs(set) actually describe the same §r(set). §cref(example_seq) visualizes the third interpretation.
        )

        §example["example_seq", "slightlywide"](Set Equality)(
          §captioned(
            §input["euler_diagrams/equality.html"]
          )(
            §p(
              Two §rs(set), with the §rs(element) that occur in exactly one of them §span(obstruction)(highlighted in red). You can change the §rs(set), note how the §rs(set) are §r(seq) exactly if no such §span(obstruction)(highlighted) §rs(element) remain.
            )
          )
        )

        §p(
          Equipped with a precise definition of §r(seq)(set equality), we can now prove some fundamental properties of §r(seq) §rs(set).
        )

        §proven_fact(
          §theorem["seq_reflexivity"](Reflexivity of §$(§$seq[true]))(
            §p(
              Let §$(A) be a §r(set). Then §$(A §$seq A)(.)
            )
          )
          §proof["seq_reflexivity"](
            §p(
              Let §$(A) be a §r(set), and let §$(a) be an object. We need to show that §$(a §$in A) if and only if §$(a §$in A)(.)§side*()(With the same proof structure, you can prove that any statement holds if and only it holds, which should not be particularly surprising. The proof of §cref(seq_reflexivity) might feel almost pointless if you look at things this way, but the §r(seq)(definition of set equality) dictates that this is how you have to prove the theorem.)
            )
            §proof_part(
              §verbatim(§$(a §$in A §$implies a §$in A)):
            )(
              §p(
                If §$(a §$in A)(,) then §$(a §$in A) by assumption.
              )
            )
            §proof_part(
              §verbatim(§$(a §$notin A §$implies a §$notin A)):
            )(
              §p(
                If §$(a §$notin A)(,) then §$(a §$notin A) by assumption.
              )
            )
            §p(
              Thus, by the §r(seq)(definition of set equality), we have that §$(A §$seq A)(.)
            )
          )
        )

        §proven_fact(
          §theorem["seq_symmetry"](Symmetry of §$(§$seq[true]))(
            §p(
              Let §$(A) and §$(B) be §rs(set). If §$(A §$seq B)(,) then §$(B §$seq A)(.)
            )
          )
          §proof["seq_symmetry"](
            §p(
              Let §$(A) and §$(B) be §rs(set), and let §$(x) be an object. Then
            )
            §fleqn(
              §$$align*(
                A §$seq B &§$implies §$text($x §$in A$ iff $x §$in B$) §$tag(§cref(set_eq)(Definition) $§$seq§ $)
              )(
                &§$implies §$text($x §$in B$ iff $x §$in A$) §$tag(§r(commutative bi-implication)(Commutativity) $§$iff§ $)
              )(
                &§$implies B §$seq A. §$tag(§cref(set_eq)(Definition) $§$seq§ $)
              )
            )
          )
        )

        §proven_fact(
          §theorem["seq_transitivity"](Transitivity of §$(§$seq[true]))(
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). If §$(A §$seq B) and §$(B §$seq C)(,) then §$(A §$seq C)(.)
            )
          )
          §proof["seq_transitivity"](
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set), and let §$(x) be an object. Then
            )
            §fleqn(
              §$$align*(
                && §$text($A §$seq B$ and $B §$seq C$)
              )(
                §$implies {} && §$text($x §$in A$ iff $x §$in B§$text(,)$ and $x §$in B$ iff $x §$in C$) §$tag(§cref(set_eq)(Definition) $§$seq§ $)
              )(
                §$implies {} && §$text($x §$in A$ iff $x §$in C$) §$tag(§r(transitive bi-implication)(Transitivity) $§$iff§ $)
              )(
                §$implies {} && A §$seq C. §$tag(§cref(set_eq)(Definition) $§$seq§ $)
              )
            )
          )
        )

        §p(
          These properties might feel so self-evidently true (just picture the §rs(Euler diagram)) that it can initially be hard to know where to even begin proving them. But the overall approach when establishing properties for freshly defined concepts is always the same: you unfold the definition of the concept until you are only working with older concepts, you use their known properties to prove what you need, and finally you translate it back into the new terminology.
        )

        §exercise["transitivity_sneq"](
          §p(
            Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Prove or disprove: if §$(A §$sneq B) and §$(B §$sneq C)(,) then §$(A §$sneq C)(.)
          )
          §solution["transitivity_sneq"](
            §p(
              We disprove the statement by giving a counterexample. Define §$(A §$defeq §$set(§$symbol0))(,) §$(B §$defeq §$set(§$symbol1))(,) and §$(C §$defeq §$set(§$symbol0))(.) Then §$(A §$sneq B) (because §$(§$symbol0 §$in A) but §$(§$symbol0 §$notin B)), §$(B §$sneq C) (because §$(§$symbol1 §$in B) but §$(§$symbol1 §$notin C)), but §$(A §$seq C)(.)
            )
          )
        )

        §p(
          The definition of §r(seq)(set equality) also justifies why we talk about §lquote§ §em(the) §r(empty set)§rquote and not §lquote§ §em(an) §r(empty set)§rquote§ . The set of numbers that are both less than 12 and greater than 17, and the set of unicorns grazing on the Eiffel §side(Tower)(None as of writing.) are precisely the same mathematical object.
        )

      )

      §hsection["subsection_subsets"](Subsets)(
        §p(
          We can think of §r(seq)(set equality) as a very strict way of looking for similarity between two §rs(set). But there are more general ways in which two §rs(set) can be related. It might be the case, for example, that one §r(set) contains all §rs(element) of another §r(set), but not necessarily the other way around. This relation is common enough that we give it a name:
        )

        §definition["subseteq"](Subset, Superset)(
          §set_math_id["subseteq", "subseteq"]
          §set_math_id["supseteq", "subseteq"]
          §set_math_id["nsubseteq", "subseteq"]
          §set_math_id["nsupseteq", "subseteq"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )§p(
            We say §$(A) is a §define(subset) of §$(B)(,) written as §$(A §$define_notation(§$subseteq) B)(,) if for each §$(x §$in A) holds §$(x §$in B)(.)
          )§p(
            Conversely, we say that §$(B) is a §define(superset) of §$(A)(,) written as §$(B §$define_notation(§$supseteq) A)(,) if §$(A §$subseteq B)(.)
          )§p(
            We further write §$(A §$define_notation(§$nsubseteq) B) if not §$(A §$subseteq B)(,) and §$(A §$define_notation(§$nsupseteq) B) if not §$(A §$supseteq B)(.)
          )
        )

        §p(
          Explore §cref(example_subseteq) for a bit. What do you expect to happen when both §rs(set) are §r(seq)? What should happen when one of them is §r(empty set)(empty)?
        )

        §example["example_subseteq", "slightlywide"](Subsets and Supersets)(
          §captioned(
            §input["euler_diagrams/subseteq.html"]
          )(
            §p(
              Two §rs(set) and the §r(subset) and §r(superset) relations between them.
            )
          )
        )

        §p(
          If you compare the definitions of §r(seq)(set equality) and §rs(subset), you can see that the definition of §rs(subset) is essentially one direction of the §r(bi-implication) in the definition of §r(seq)(set equality). In other words, two §rs(set) are §r(seq) if they are both §rs(subset) and §rs(superset) of each other. Formally:
        )

        §proven_fact(
          §observation["sequality_and_subsets"](
            Let §$(A) and §$(B) be §rs(set). Then §$(A §$seq B) if and only if §$(A §$subseteq B) and §$(A §$supseteq B)(.)
          )
          §proof["sequality_and_subsets"](
            §side*()(Proofs are hidden in this book when either it makes for a good exercise to try to prove the statement yourself, or when they are uninteresting enough to only be included for the sake of completeness. Which option it is, depends on you and how well you grasp the material already. When in doubt, use them as an opportunity to improve your skills.)
            §proof_as_exercise["sequality_and_subsets"](
              §proof_part(
                §verbatim(§$(A §$seq B §$implies A §$subseteq B) and §$(A §$supseteq B)):
              )(
                §p(
                  Assume §$(A §$seq B)(.) We now show that §$(A §$subseteq B) and §$(A §$supseteq B)(.) To that end, let §$(x) be an object.
                )§p(
                  If §$(x §$in A)(,) then also §$(x §$in B)(,) because §$(A §$seq B)(.) Thus, §$(A §$subseteq B)(.)
                )§p(
                  Analogously, if §$(x §$in B)(,) then also §$(x §$in A)(,) because §$(A §$seq B)(.) Thus, §$(A §$supseteq B)(.)
                )
              )
              §proof_part(
                §verbatim(§$(A §$subseteq B) and §$(A §$supseteq B §$implies A §$seq B)):
              )(
                §p(
                  Assume that §$(A §$subseteq B) and §$(A §$supseteq B)(.) We now show that §$(A §$seq B)(.) To that end, let §$(x) be an object.
                )
                §proof_part(
                  §verbatim(§$(x §$in A §$implies x §$in B)):
                )(
                  If §$(x §$in A)(,) then §$(x §$in B)(,) because §$(A §$subseteq B)(.)
                )
                §proof_part(
                  §verbatim(§$(x §$in B §$implies x §$in A)):
                )(
                  If §$(x §$in B)(,) then §$(x §$in A)(,) because §$(A §$supseteq B)(.)
                )
              )
            )
          )
        )

        §p(
          This alternate characterization offers yet another way of proving §r(seq)(set equality); you can show that two §rs(set) are §r(seq) by showing that they are mutual §rs(subset).
        )

        §p(
          If you played around a bit with §cref(example_subseteq), you may have noticed that the §r(empty set) is a §r(subset) of every set. To understand why, we need to take a close look at how §rs(subset) are defined. The §r(subset)(definition) talks about §lquote§ all §$(x §$in A)(§rquote§ ,) so what happens if §$(A §$seq §$set)(?) There exists no §$(x) such that §$(x §$in §$set)(,) so what does that mean for the §r(subset)(definition)?
        )§p(
          On an intuitive level, you can say that in order to show that some §r(set) is a §r(subset) of another, you need to show that a certain property holds for each of its §rs(member). As the §r(empty set) has no §rs(member), you do not need to show anything.
        )§p(
          More formally, the phrase §verbatim(for)(each §$(x §$in A) holds)(§meta1) is a shorthand for the phrase §verbatim(for)(each object §$(x) holds that §$(x §$in A) implies)(§meta1). With that knowledge, we can formally prove that the §r(empty set) is a §r(subset) of every set:
        )

        §proven_fact(
          §theorem["empty_set_subset_everything"](
            §p(Let §$(A) be a §r(set). Then §$(§$set §$subseteq A)(.))
          )
          §proof["empty_set_subset_everything"](
            §p(
              Let §$(x) be an object. We need to show that §$(x §$in §$set) implies §$(x §$in A)(,) so assume that §$(x §$in §$set)(.)
            )§p(
              Because the §r(empty set) has no §rs(member), we know that §$(x §$notin §$set)(.) As we cannot have §$(x §$in §$set) and §$(x §$notin §$set) simultaneously (by the §r(principle of bivalence)), §$(x §$in A) holds by the §r(principle of explosion).
            )
          )
        )

        §p(
          Whenever a statement of §r(universal quantification) holds because it is constrained to elements from the §r(empty set), we say that the statement holds §define["vacuously_truth"](vacuously).
        )

        §exercise["vacuous_nontruth"](
          §p(
            Based on your knowledge about §r(negation)(negating) §rs(universal quantification), give a full picture of how statements like §verbatim(there)(§em(exists) §$(x §$in §$set) such that)(§meta1) work out.
          )
          §solution["vacuous_nontruth"](
            §p(
              Such a statement is always false; intuitively speaking, it is impossible to find a §r(witness) that is §r(in) the §r(empty set).
            )
            §p(
              §verbatim(There)(exists §$(x §$in §$set) such that)(§meta1) is §r(bi-implication)(equivalent) to its §r(double negation) §verbatim(it)(does not hold that there exists no §$(x §$in §$set) such that)(§meta1). This in turn is §r(bi-implication)(equivalent) to §verbatim(it)(does not hold that for each §$(x §$in §$set))(not §meta1), which is the §r(negation) of a §r(vacuously) true statement, and thus false.
            )
          )
        )

        §p(
          The concept of §rs(subset) is ubiquitous in mathematics, so use the following exercises and theorems to familiarize yourself with it. They also present a good opportunity to practice your §r(deductive reasoning) skills.
        )

        §exercise["exercise_partial_subsets"](
          §p(
            Give §rs(set) §$(A)(,) §$(B)(,) and §$(C)(,) such that §$(A §$subseteq C) and §$(B §$subseteq C)(,) but §$(A §$nsubseteq B) and §$(B §$nsubseteq A)(.)
          )
          §solution["exercise_partial_subsets"](
            §p(
              Define §$(A §$defeq §$set(§$symbol0))(,) §$(B §$defeq §$set(§$symbol1))(,) and §$(C §$defeq §$set(§$symbol0)(§$symbol1))(.) Then §$(A §$subseteq C) and §$(B §$subseteq C)(,) but §$(A §$nsubseteq B) §lparen§ because §$(§$symbol0 §$in A) but §$(§$symbol0 §$notin B)(§rparen) and §$(B §$nsubseteq A) §lparen§ because §$(§$symbol1 §$in B) but §$(§$symbol1 §$notin A)(§rparen§ .)
            )
          )
        )

        §proven_fact(
          §theorem["subseteq_reflexivity"](Reflexivity of §$(§$subseteq[true]))(
            §p(
              Let §$(A) be a §r(set). Then §$(A §$subseteq A)(.)
            )
          )
          §proof["subseteq_reflexivity"](
            §proof_as_exercise["subseteq_reflexivity"](
              §p(
                Let §$(A) be a §r(set), and let §$(x) be an object. If §$(a §$in A)(,) then §$(a §$in A) by assumption, and thus §$(A §$subseteq A)(.)
              )
            )
          )
        )

        §proven_fact(
          §theorem["subseteq_transitivity"](Transitivity of §$(§$subseteq[true]))(
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). If §$(A §$subseteq B) and §$(B §$subseteq C)(,) then §$(A §$subseteq C)(.)
            )
          )
          §proof["subseteq_transitivity"](
            §proof_as_exercise["subseteq_transitivity"](
              §p(
                Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set), and let §$(x) be an object. Assume that §$(A §$subseteq B) and §$(B §$subseteq C)(.) Then
              )§$$align*(
                && x &§$in A
              )(
                §$implies {} && x &§$in B §$tag($A §$subseteq B$)
              )(
                §$implies {} && x &§$in C, §$tag($B §$subseteq C$)
              )§p(
                and thus §$(A §$subseteq C)(.)
              )
            )
          )
        )

        §exercise["subseteq_cyclic"](
          §p(
            Prove or disprove: there exist §rs(set) §$(A)(,) §$(B)(,) and §$(C) such that §$(A §$subseteq B)(,) §$(B §$subseteq C)(,) and §$(C §$subseteq A)(.)
          )
          §solution["subseteq_cyclic"](
            §p(
              The statement holds. Define §$(A §$defeq §$set)(,) §$(B §$defeq §$set)(,) and §$(C §$defeq §$set)(.) Then §$(A §$subseteq B)(,) §$(B §$subseteq C)(,) and §$(C §$subseteq A) by §cref(subseteq_reflexivity).§side*()(Bonus exercise: show that for all §rs(set) §$(A)(,) §$(B)(,) and §$(C) holds that §$(A §$subseteq B)(,) §$(B §$subseteq C) and §$(C §$subseteq A) if and only if §$(A §$seq B) and §$(B §$seq C)(.))
            )
          )
        )

      )

      §hsection["subsection_strict_subsets"](Strict Subsets)(
        §p(
          §Rs(subset) express that some §r(set) contains at least every §r(member) of another §r(set). Sometimes we want to express that a §r(set) also contains at least one further object:
        )

        §definition["subset"](Strict Subset, Strict Superset)(
          §set_math_id["subset", "subset"]
          §set_math_id["supset", "subset"]
          §set_math_id["nsubset", "subset"]
          §set_math_id["nsupset", "subset"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )§p(
            We say §$(A) is a §define(strict subset) of §$(B)(,) written as §$(A §$define_notation(§$subset) B)(,) if §$(A §$subseteq B) and §$(A §$sneq B)(.)
          )§p(
            Conversely, we say §$(A) is a §define(strict superset) of §$(B)(,) written as §$(A §$define_notation(§$supset) B)(,) if §$(A §$supseteq B) and §$(A §$sneq B)(.)
          )§p(
            We further write §$(A §$define_notation(§$nsubset) B) if not §$(A §$subset B)(,) and §$(A §$define_notation(§$nsupset) B) if not §$(A §$supset B)(.)
          )
        )

        §p(
          Being a §r(strict subset) is a stronger notion than being a §r(subset), that is, every §r(strict subset) of some §r(set) is also a regular §r(subset) of that §r(set):
        )

        §proven_fact(
          §observation["subset_is_subseteq"](
            §p(
              Let §$(A) and §$(B) be §rs(set). If §$(A §$subset B)(,) then §$(A §$subseteq B)(.)
            )
          )
          §proof["subset_is_subseteq"](
            §proof_as_exercise["subset_is_subseteq"](
              §p(
                Let §$(A) and §$(B) be §rs(set). Then
              )
              §$$align*(
                A §$subset B &§$implies §$text($A §$subseteq B$ and $A §$sneq B$) §$tag(§cref(subset)(Definition) $§$subset[true]$)
              )(
                &§$implies A §$subseteq B §$tag(§R(conjunction))
              )
            )
          )
        )

        §p(
          §Rs(strict subset) behave similar to (possibly non-strict) §rs(subset), but the following exercises also highlight some differences.
        )

        §proven_fact(
          §theorem["subset_transitivity"](Transitivity of §$(§$subset[true]))(
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). If §$(A §$subset B) and §$(B §$subset C)(,) then §$(A §$subset C)(.)
            )
          )
          §proof["subset_transitivity"](
            §proof_as_exercise["subset_transitivity"](
              §p(
                Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Assume that §$(A §$subset B) and §$(B §$subset C)(.)
              )§p(
                By §cref(subset_is_subseteq) we have that §$(A §$subseteq B) and §$(B §$subseteq C)(,) and by the §cref(subseteq_transitivity)(transitivity of §$(§$subseteq[true])) we have that §$(A §$subseteq C)(.) It remains to show that §$(A §$sneq C)(.)
              )§p(
                Since §$(A §$sneq B) but every §r(member) of §$(A) is a §r(member) of §$(B) (both hold because §$(A §$subset B)), there exists some §$(x §$in B) with §$(x §$notin A)(.) Because §$(x §$in B) and §$(B §$subset C)(,) we know that §$(x §$in C). And as §$(x §$notin A)(,) we get that §$(A §$sneq C)(.)
              )
            )
          )
        )

        §exercise["subset_antisymmetry"](
          §p(
            Let §$(A) and §$(B) be §rs(set). Prove or disprove: if §$(A §$subset B) and §$(B §$subset A)(,) then §$(A §$seq B)(.)
          )
          §solution["subset_antisymmetry"](
            §p(
              Let §$(A) and §$(B) be §rs(set) such that §$(A §$subset B) and §$(B §$subset A)(.) Then also §$(A §$subseteq B) and §$(B §$subseteq A) by §cref(subset_is_subseteq), and thus §$(A §$seq B) by §cref(sequality_and_subsets).§side*()(You may have noticed that §$(A §$seq B) contradicts the assumptions of §$(A §$subset B) and §$(B §$subset A)(,) as the §r(strict subset) relation precludes §r(seq)(equality) by definition. This has no consequences for the validity of the proof however, because any §r(implication) with a false §r(premise) holds regardless.)
            )
          )
        )

        §exercise["subset_cyclic"](
          §p(
            Prove or disprove: there exist §rs(set) §$(A)(,) §$(B)(,) and §$(C) such that §$(A §$subset B)(,) §$(B §$subset C)(,) and §$(C §$subset A)(.)
          )
          §solution["subset_cyclic"](
            §p(
              The statement does not hold, so we prove its §r(negation). Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set), and suppose toward a contradiction that §$(A §$subset B)(,) §$(B §$subset C)(,) and §$(C §$subset A)(.)
            )§p(
              Because §$(A §$subset B)(,) there exists §$(x §$in B) such that §$(§$highlightlow6(x §$notin A))(.) Then §$(x §$in C)(,) because §$(x §$in B) and §$(B §$subset C)(.) But then also §$(§$highlightlow6(x §$in A))(,) because §$(x §$in C) and §$(C §$subset A)(,) a contradiction.
            )
          )
        )

      )

    )

    §hsection["combining_sets"](Combining Sets)(
      §p(
        When considering multiple §rs(set), some objects might be §r(in) exactly one of them, while others might be §r(in) multiple of them. Take, for example, the three §rs(set) of animal species that can walk, swim, or fly respectively. We might be interested in the set of all species that can walk and swim but cannot fly. In this section, we introduce terminology for deriving such §rs(set) from other §rs(set).
      )

      §p(
        §cref(my_first_venn_diagram) visualizes the example in a §definex["venn_diagram"](Venn diagram)(
          §p(
            A §rdef(Venn diagram) visualizes all possible ways in which a number of §rs(set) can overlap:
          )
          §div(venn3_container centered)(
            §input["venn_diagrams/definition_venn.svg"]
          )
        ), a special type of §r(Euler diagram) that shows all possible ways in which some §rs(set) can overlap.
      )

      §figure["my_first_venn_diagram"](
        §captioned(
          §div{"style": "display: flex; flex-direction: column;"}(
            <svg id="first_venn" class="venn" version="1.1" viewBox="-55 -60 110 110" xmlns="http://www.w3.org/2000/svg">
              <!-- A -->
              <clipPath id="clip_a_first_venn">
                <circle cx="-17.3205" cy="10" r="30.5"/>
              </clipPath>

              <!-- A intersect B -->
              <clipPath id="clip_aib_first_venn" clip-path="url('#clip_a_first_venn')">
                <circle cx="0" cy="-20" r="30.5"/>
              </clipPath>

              <!-- A intersect B intersect C -->
              <clipPath id="clip_aibic_first_venn" clip-path="url('#clip_aib_first_venn')">
                <circle cx="17.3205" cy="10" r="30.5"/>
              </clipPath>

              <!-- a intersect B intersect C -->
              <mask id="mask_aibic_first_venn" >
                <rect x="-55" y="-60" width="110" height="110" style="fill: white;"/>
                <rect clip-path="url('#clip_aibic_first_venn')" x="-55" y="-60" width="110" height="110" style="fill: black;"/>
              </mask>


              <circle class="cd1 bgclll1" cx="-17.3205" cy="10" r="30"/>
              <circle class="cd5 bgclll5" cx="0" cy="-20" r="30"/>
              <circle class="cd3 bgclll3" cx="17.3205" cy="10" r="30"/>

              <text x="§polar_x[150.0, 30.0, 0.0]" y="§polar_y[150.0, 30.0, 0.0]">&#xe906;</text>
              <text x="§polar_x[270.0, 30.0, 0.0]" y="§polar_y[270.0, 30.0, 0.0]">&#xe905;</text>
              <text x="§polar_x[30.0, 30.0, 0.0]" y="§polar_y[30.0, 30.0, 0.0]">&#xe904;</text>
              <text x="§polar_x[90.0, 20.0, 0.0]" y="§polar_y[90.0, 20.0, 0.0]">&#xe903;</text>
              <text x="§polar_x[210.0, 20.0, 0.0]" y="§polar_y[210.0, 20.0, 0.0]">&#xe902;</text>
              <text x="§polar_x[330.0, 20.0, 0.0]" y="§polar_y[330.0, 20.0, 0.0]">&#xe901;</text>
              <text x="0" y="0" style="font-size: 0.62rem;">&#xe900;</text>

              <!-- A intersect B intersect C -->
              <rect id="duck_region" class="first_venn_region" clip-path="url('#clip_aibic_first_venn')" x="-55" y="-60" width="110" height="110"/>
            </svg>

          )
          §div(duck_container)()(
            §div(img_container)(
              <img src="./assets/images/duck.png">
            )
          )
        )(
          §p(
            A §r(Venn diagram) showing the §rs(set) of animal species that can §span(cd5 highlight bgclll5)(walk), §span(cd1 highlight bgclll1)(fly), and §span(cd3 highlight bgclll3)(swim). Each of the seven resulting regions shows an §side(icon)(§cref(attribution_species)(Attribution).) of a species that belongs to it.
          )
        )
      )

      §p(
        So far, we have always denoted §rs(set) by explicitly enumerating their §rs(member), which does not help us when trying to define a §r(set) in terms of other §rs(set). For that reason, we introduce the §definex["set_builder_notation_preliminary", "set builder notation"](set builder notation)(set builder notations)(
          §p(
            In §rdef(set builder notation)(set builder notation), we define a §r(set) by giving a §r(predicate) that holds for exactly the §rs(member) of that §r(set):
            §$$(
              §$set_builder[1](x)(§$text($x §$in §$set(§$symbol0)(§$symbol1)(§$symbol2)$ and $x §$in §$set(§$symbol0)(§$symbol2)(§$symbol3)$)) §$seq §$set(§$symbol0)(§$symbol2).
            )
          )§p(
            Read the above example as §lquote§ the §r(set) that contains all §$(x) such that §$(x §$in §$set(§$symbol0)(§$symbol1)(§$symbol2)) and §$(x §$in §$set(§$symbol0)(§$symbol2)(§$symbol3))(§rquote§ .)
          )
        ), in which we specify a §r(set) by giving a §r(predicate) that is satisfied exactly by the §rs(member) of that §r(set) (read the vertical bar (§verbatim(§$(§$mid))) as §verbatim(such)(that)):
      )§p(
        §$(§$set_builder[1](x)(§$text($x §$in §$set(§$symbol0)(§$symbol1)(§$symbol2)$ and $x §$in §$set(§$symbol0)(§$symbol2)(§$symbol3)$)))(,) for example, is a complicated way of denoting the §r(set) §$(§$set(§$symbol0)(§$symbol2))(.)
      )§p(
        As this notation is more of a technicality than an interesting new concept, we shall not dwell on it any further.
      )

      §hsection["intersection_and_union"](Intersection and Union)(
        <svg xmlns="http://www.w3.org/2000/svg" width="0" height="0">
        	<defs>
        		<pattern id="pattern_euler_yay" patternUnits="userSpaceOnUse" width="8" height="8">
              <path d='M0 0L8 8ZM8 0L0 8Z' stroke-width='2.5' style="stroke: var(--c6)"/>
        		</pattern>
        	</defs>
        </svg>

        §p(
          We now define our terminology for the objects that occur in both of two §rs(set):
        )

        §definition_marginalia(
          §venn_intersection
        )(
          §definition["intersection"](Intersection)(
            §set_math_id["intersection", "intersection"]
            §p(
              Let §$(A) and §$(B) be §rs(set).
            )
            §p(
              The §define(intersection) of §$(A) and §$(B)(,) written as §$(A §$define_notation(§$intersection) B)(,) is the §r(set) of all objects which are §rs(element) of both §$(A) and §$(B)(:)

              §$$(
                A §$intersection B §$defeq §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)).
              )
            )
          )
        )

        §example["example_intersection", "slightlywide"](Intersection)(
          §input["euler_diagrams/intersection.html"]
        )

        §p(
          If we swap the §r(conjunction) in the definition of the §r(intersection) of two §rs(set) for a §r(disjunction), we obtain another useful concept:
        )

        §definition_marginalia(
          §venn_union
        )(
          §definition["union"](Union)(
            §set_math_id["union", "union"]
            §p(
              Let §$(A) and §$(B) be §rs(set).
            )
            §p(
              The §define(union) of §$(A) and §$(B)(,) written as §$(A §$define_notation(§$union) B)(,) is the §r(set) of all objects which are §rs(element) of at least one of §$(A) or §$(B)(:)

              §$$(
                A §$union B §$defeq §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)).
              )
            )
          )
        )

        §example["example_union", "slightlywide"](Union)(
          §input["euler_diagrams/union.html"]
        )

        §p(
          §R(intersection) and §r(union) are §definex["binary_operator"](binary operator)(binary operators)(binary operators)(
            §p(
              A §rdef(binary operator) combines exactly two objects into a new object.
            )
          ), that is, they combine exactly two §rs(set). If we wish to combine more than two §rs(set), we group the §rs(set) as pairs in parentheses and can then compute those pairs successively:
        )

        §p(
          §$$align*(
            & §$p[2](§$set(§$symbol0)(§$symbol1)(§$symbol2) §$intersection §$highlightlow1(§$p[1](§$set(§$symbol1)(§$symbol3) §$union §$set(§$symbol1)(§$symbol2)(§$symbol3)))) §$union §$set
          )(
            §$seq {} & §$highlightlowr3(§$p[1](§$set(§$symbol0)(§$symbol1)(§$symbol2) §$intersection §$highlighttop1(§$set(§$symbol1)(§$symbol2)(§$symbol3)))) §$union §$set
          )(
            §$seq {} & §$highlightlow5(§$highlighttopr3(§$set(§$symbol1)(§$symbol2)) §$union §$set)
          )(
            §$seq {} & §$highlighttop5(§$set(§$symbol1)(§$symbol2))
          )
        )

        §p(
          The next exercise gives you ample opportunities to practice computing such expressions, you can generate new expressions and solutions with the click of a button.
        )

        §exercise["practice_intersection_union_direct"](
          §p(
            Compute §span(practice_intersection_union_direct_text)()()
          )

          §solution["practice_intersection_union_direct"](
            §div(practice_intersection_union_direct_solution)()()
          )
          §p(
            §button(practice_intersection_union_direct_new)()(New Exercise)
          )
        )

        §p(
          Grouping nested §rs(intersection) and §rs(union) with parentheses is necessary in general, because there are expressions for which the exact grouping makes a difference in the result:
        )

        §proven_fact(
          §statement["intersection_union_parens"](
            §p(
              There exist §rs(set) §$(A)(,) §$(B)(,) and §$(C) such that §$(§$p(A §$intersection B) §$union C §$sneq A §$intersection §$p(B §$union C))(.)
            )
          )
          §proof["intersection_union_parens"](
            §proof_as_exercise["intersection_union_parens"](
              §fleqn(
                §p(
                  Define §$(A §$defeq §$set)(,) §$(B §$defeq §$set)(,) and §$(C §$defeq §$set(§$symbol0))(.) Then §$$align*(
                    §$p(A §$intersection B) §$union C &§$seq §$p(§$set §$intersection §$set) §$union §$set(§$symbol0) §$tag(Definition $A, B, C$)
                  )(
                    &§$seq §$set §$union §$set(§$symbol0) §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    &§$seq §$set(§$symbol0), §$tag(§cref(union)(Definition) $§$union§ $)
                  ) but §$$align*(
                    A §$intersection §$p(B §$union C) &§$seq §$set §$intersection §$p(§$set §$union §$set(§$symbol0)) §$tag(Definition $A, B, C$)
                  )(
                    &§$seq §$set §$intersection §$set(§$symbol0) §$tag(§cref(union)(Definition) $§$union§ $)
                  )(
                    &§$seq §$set§ , §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  ) and §$(§$set(§$symbol0) §$sneq §$set)(.)
                )
              )
            )
          )
        )

        §p(
          The grouping does not affect the result however when they are only §rs(intersection) or only §rs(union) involved.
        )

        §fact_marginalia(
          §venn_associative_intersection
        )(
          §proven_fact(
            §theorem["associative_intersection"](Associativity of §$(§$intersection[true]§ ))(
              §p(
                Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Then §$(§$p(A §$intersection B) §$intersection C §$seq A §$intersection §$p(B §$intersection C))(.)
              )
            )
            §proof["associative_intersection"](
              §fleqn(
                §p(
                  Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Then §$$align*(
                    &§$p(A §$intersection B) §$intersection C
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$intersection C §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    §$seq {} & §$set_builder[1](y)(§$text($y §$in §$set_builder(x)(§$text($x §$in A$ and $x §$in B$))$ and $y §$in C$)) §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    §$seq {} & §$set_builder(x)(§$text(($x §$in A$ and $x §$in B$) and $x §$in C$)) §$tag(§R(set builder notation))
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ and ($x §$in B$ and $x §$in C$))) §$tag(§r(associative conjunction)(Asso.) §r(conjunction))
                  )(
                    §$seq {} & §$set_builder[1](y)(§$text($y §$in A$ and $y §$in §$set_builder(x)(§$text($x §$in B$ and $x §$in C$))$)) §$tag(§R(set builder notation))
                  )(
                    §$seq {} & A §$intersection §$set_builder(x)(§$text($x §$in B$ and $x §$in C$)) §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    §$seq {} & A §$intersection §$p(B §$intersection C). §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )
                )
              )
            )
          )
        )

        §fact_marginalia(
          §venn_associative_union
        )(
          §proven_fact(
            §theorem["associative_union"](Associativity of §$(§$union[true]§ ))(
              §p(
                Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Then §$(§$p(A §$union B) §$union C §$seq A §$union §$p(B §$union C))(.)
              )
            )
            §proof["associative_union"](
              §proof_as_exercise["associative_union"](
                §fleqn(
                  §p(
                    Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Then §$$align*(
                      &§$p(A §$union B) §$union C
                    )(
                      §$seq {} & §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)) §$union C §$tag(§cref(union)(Definition) $§$union§ $)
                    )(
                      §$seq {} & §$set_builder[1](y)(§$text($y §$in §$set_builder(x)(§$text($x §$in A$ or $x §$in B$))$ or $y §$in C$)) §$tag(§cref(union)(Definition) $§$union§ $)
                    )(
                      §$seq {} & §$set_builder(x)(§$text(($x §$in A$ or $x §$in B$) or $x §$in C$)) §$tag(§R(set builder notation))
                    )(
                      §$seq {} & §$set_builder(x)(§$text($x §$in A$ or ($x §$in B$ or $x §$in C$))) §$tag(§r(associative disjunction)(Asso.) §r(disjunction))
                    )(
                      §$seq {} & §$set_builder[1](y)(§$text($y §$in A$ or $y §$in §$set_builder(x)(§$text($x §$in B$ or $x §$in C$))$)) §$tag(§R(set builder notation))
                    )(
                      §$seq {} & A §$union §$set_builder(x)(§$text($x §$in B$ or $x §$in C$)) §$tag(§cref(union)(Definition) $§$union§ $)
                    )(
                      §$seq {} & A §$union §$p(B §$union C). §$tag(§cref(union)(Definition) $§$union§ $)
                    )
                  )
                )
              )
            )
          )
        )



        §p(
          If the way in which we group multiple occurrences of a §r(binary operator) has no influence on the result, we call that §r(binary operator)(operator) §define["binop_associative"](associative). To keep our notation clean from unnecessary details, we allowed to omit grouping parentheses for §r(associative) §rs(binary operator)(operators). It is fine, for example, to write §$(§lquote)(A §$union B §$union C)(§rquote§ .) For all §rs(binary operator) that have not been proven §r(associative), we always provide the parentheses to indicate the exact grouping.
        )

        §p(
          §R(intersection) and §r(union) inherit the §r(associative conjunction)(associativity) of §rs(conjunction) and §rs(disjunction) respectively fairly directly. Using structurally similar proofs, we can show that they inherit their §r(commutative conjunction)(commutativity) as well:
        )

        §proven_fact(
          §theorem["commutative_intersection"](Commutativity of §$(§$intersection[true]§ ))(
            §p(
              Let §$(A) and §$(B) be §rs(set). Then §$(A §$intersection B §$seq B §$intersection A)(.)
            )
          )
          §proof["commutative_intersection"](
            §proof_as_exercise["commutative_intersection"](
              §fleqn(
                §p(
                  Let §$(A) and §$(B) be §rs(set). Then §$$align*(
                    &A §$intersection B
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in B$ and $x §$in A$)) §$tag(§r(commutative conjunction)(Commutativity) §r(conjunction))
                  )(
                    §$seq {} & B §$intersection A. §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )
                )
              )
            )
          )
        )

        §proven_fact(
          §theorem["commutative_union"](Commutativity of §$(§$union[true]§ ))(
            §p(
              Let §$(A) and §$(B) be §rs(set). Then §$(A §$union B §$seq B §$union A)(.)
            )
          )
          §proof["commutative_union"](
            §proof_as_exercise["commutative_union"](
              §fleqn(
                §p(
                  Let §$(A) and §$(B) be §rs(set). Then §$$align*(
                    &A §$union B
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ or $x §$in B$)) §$tag(§cref(union)(Definition) $§$union§ $)
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in B$ or $x §$in A$)) §$tag(§r(commutative disjunction)(Commutativity) §r(disjunction))
                  )(
                    §$seq {} & B §$union A. §$tag(§cref(union)(Definition) $§$union§ $)
                  )
                )
              )
            )
          )
        )

        §p(
          Two further simple but useful observations are that §rs(intersection) never add elements, and §rs(union) never remove elements:
        )

        §proven_fact(
          §theorem["intersection_nonincreasing"](
            §p(
              Let §$(A) and §$(B) be §rs(set). Then §$(A §$intersection B §$subseteq A)(.)
            )
          )
          §proof["intersection_nonincreasing"](
            §p(
              Let §$(A) and §$(B) be §rs(set), and let §$(x) be an object. If §$(x §$in A §$intersection B)(,) then also §$(x §$in A) by definition of §$(§$intersection)(,) and thus §$(A §$intersection B §$subseteq A)(.)
            )
          )
        )

        §proven_fact(
          §theorem["union_nondecreasing"](
            §p(
              Let §$(A) and §$(B) be §rs(set). Then §$(A §$subseteq A §$union B)(.)
            )
          )
          §proof["union_nondecreasing"](
            §proof_as_exercise["union_nondecreasing"](
              §p(
                Let §$(A) and §$(B) be §rs(set), and let §$(x) be an object. If §$(x §$in A)(,) then also §$(x §$in A §$union B) by definition of §$(§$union)(,) and thus §$(A §$subseteq A §$union B)(.)
              )
            )
          )
        )

        §p(
          The following exercises present further opportunities to become more familiar with §rs(intersection) and §rs(union), as well as to practice proving statements in general.
        )

        §exercise["exercise_characterize_subseteq"](
          §p(
            Let §$(A) and §$(B) be §rs(set). Show that §$(A §$subseteq B) if and only if §$(A §$intersection B §$seq A)(.)
          )

          §solution["exercise_characterize_subseteq"](
            §fleqn(
              §p(
                Let §$(A) and §$(B) be §rs(set).
              )

              §proof_part(
                §verbatim(§$(A §$subseteq B §$implies A §$intersection B §$seq A)):
              )(
                §p(
                  Assume §$(A §$subseteq B)(.) Then §$$align*(
                    & A §$intersection B
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    §$seq {} & §$set_builder(x)(§$text($x §$in A$)) §$tag($x §$in A §$implies x §$in B$)
                  )(
                    §$seq {} & A. §$tag(§R(set builder notation))
                  )
                )
              )§proof_part(
                §verbatim(§$(A §$nsubseteq B §$implies A §$intersection B §$sneq A)):
              )(
                §p(
                  Assume §$(A §$nsubseteq B)(.) Then there is §$(a §$in A) such that §$(a §$notin B)(.) Then §$$align*(
                    & a §$notin B
                  )(
                    §$implies {} & a §$notin §$set_builder(x)(§$text($x §$in A$ and $x §$in B$)) §$tag(§R(conjunction))
                  )(
                    §$implies {} & a §$notin A §$intersection B §$tag(§cref(intersection)(Definition) $§$intersection§ $)
                  )(
                    §$implies {} & A §$sneq A §$intersection B. §$tag($a §$in A$, Definition $§$seq§ $)
                  )
                )
              )
            )
          )
        )

        §exercise["exercise_union_subseteq"](
          §p(
            Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set) with §$(A §$subseteq C) and §$(B §$subseteq C)(.) Show that §$(A §$union B §$subseteq C).
          )

          §solution["exercise_union_subseteq"](
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set), let §$(x) be an object, and assume that §$(A §$subseteq C) and §$(B §$subseteq C)(.)
            )§p(
              Assume that §$(x §$in A §$union B)(.) We then need to show that §$(x §$in C)(.) As §$(x §$in A §$union B)(,) we know that §$(x §$in A) or §$(x §$in B)(,) hence we can do a case distinction.
            )§cases(
              §case(§$(x §$in A))(
                If §$(x §$in A)(,) then, because §$(A §$subseteq C), we have that §$(x §$in C)(.)
              )
              §case(§$(x §$in B))(
                If §$(x §$in B)(,) then, because §$(B §$subseteq C), we have that §$(x §$in C)(.)
              )
            )
          )
        )

        §fact_marginalia(
          §venn_absorption_intersection_union
        )(
          §proven_fact(
            §theorem["exercise_intersection_union_absorption"](Absorption of §$(§$intersection[true]) and §$(§$union[true]))(
              §p(
                Let §$(A) and §$(B) be §rs(set). Then
              )§ol(
                §li(
                  §$(A §$intersection §$p(A §$union B) §$seq A)(,) and
                )§li(
                  §$(A §$union §$p(A §$intersection B) §$seq A)(.)
                )
              )
            )
            §proof["exercise_intersection_union_absorption"](
              §p(
                Let §$(A) and §$(B) be §rs(set).
              )§ol(
                §li(
                  §proof_as_exercise["exercise_intersection_union_absorption_1"](
                    §proof_part(
                      §verbatim(§$(A §$intersection §$p(A §$union B) §$subseteq A))
                    )(
                      §p(
                        Holds by §cref(intersection_nonincreasing).
                      )
                    )§proof_part(
                      §verbatim(§$(A §$intersection §$p(A §$union B) §$supseteq A))
                    )(
                      §p(
                        Let §$(x) be an object. If §$(x §$in A)(,) then also §$(A §$union B)(,) and then also §$(x §$in A §$intersection §$p(A §$union B))(.)
                      )
                    )
                  )
                )

                §li(
                  §proof_as_exercise["exercise_intersection_union_absorption_2"](
                    §proof_part(
                      §verbatim(§$(A §$union §$p(A §$intersection B) §$subseteq A))
                    )(
                      §p(
                        We show the §r(contraposition), that is, we show that if an object is not §r(in) §$(A)(,) then it is not §r(in) §$(A §$union §$p(A §$intersection B)) either. To that end, let §$(x) be an object. If §$(x §$notin A)(,) then also §$(x §$notin A §$intersection B)(,) and then also §$(x §$notin A §$union §$p(A §$intersection B))(.)
                      )
                    )§proof_part(
                      §verbatim(§$(A §$union §$p(A §$intersection B) §$supseteq A))
                    )(
                      §p(
                        Holds by §cref(union_nondecreasing).
                      )
                    )
                  )
                )
              )
            )
          )
        )

        §exercise["exercise_diagram_as_proof"](
          §p(
            §cref(exercise_intersection_union_absorption) is annotated with a series of §rs(Venn diagram) which demonstrate that the equation in question holds. Other, similar statements include such visualizations as well (§cref(associative_intersection), §cref(associative_union), not displayed in the tooltips). A diagram is clearly not a (written) proof, the actual proofs do not directly relate to the diagrams, and yet these visualizations unescapably convey the §r(seq)(equality) of the two sides of the equation.
          )§ol(
            §li(
              How can the information contained in such a diagram be mechanically translated into a proof of §r(seq)(equality)?
            )§li(
              Give a written proof of §cref(exercise_intersection_union_absorption) that corresponds directly to the visualization.
            )§li(
              How do you feel about these proofs compared to more natural proofs like those given in the book?
            )
          )

          §solution["exercise_diagram_as_proof"](
            §ol(
              §li(
                §p(
                  Every region of a §r(Venn diagram) corresponds to one particular way in which the §r(member)(membership) of some object with respect to all involved §rs(set) can work out. The diagram as a whole lists §em(all) possible ways in which any object can relate to the §rs(set) (the easily forgotten outer region corresponds to objects which are not §rs(member) of any depicted §r(set)).
                )§p(
                  So overall, we can translate a diagram into a written proof by taking some object §$(x), and then doing a §r(case distinction) over §r(member)(membership) in all §rs(set) in question. In each individual case, the information about §r(member)(set membership) suffices to compute whether the object is §r(in) further §rs(intersection) or §rs(union). Thus we can show that in each case the object is either §r(in) both or none of the §rs(set) on either side of the equation.
                )
              )§li(
                §p(
                  Let §$(A) and §$(B) be sets, and let §$(x) be an object. We show that §$(x §$in A §$intersection §$p(A §$union B)) if and only if §$(x §$in A)(.)
                )§cases(
                  §case(§$(x §$notin A) and §$(x §$notin B))(
                    If §$(x §$notin A) and §$(x §$notin B)(,) then §$(x §$notin A §$union B)(,) and then §$(x §$notin A §$intersection §$p(A §$union B))(.) As also §$(x §$notin A) by assumption, we have §$(x §$in A §$intersection §$p(A §$union B)) if and only if §$(x §$in A) in this case.
                  )§case(§$(x §$notin A) and §$(x §$in B))(
                    If §$(x §$notin A) and §$(x §$in B)(,) then §$(x §$in A §$union B)(,) and then §$(x §$notin A §$intersection §$p(A §$union B))(.) As also §$(x §$notin A) by assumption, we have §$(x §$in A §$intersection §$p(A §$union B)) if and only if §$(x §$in A) in this case.
                  )§case(§$(x §$in A) and §$(x §$notin B))(
                    If §$(x §$in A) and §$(x §$notin B)(,) then §$(x §$in A §$union B)(,) and then §$(x §$in A §$intersection §$p(A §$union B))(.) As also §$(x §$in A) by assumption, we have §$(x §$in A §$intersection §$p(A §$union B)) if and only if §$(x §$in A) in this case.
                  )§case(§$(x §$in A) and §$(x §$in B))(
                    If §$(x §$in A) and §$(x §$in B)(,) then §$(x §$in A §$union B)(,) and then §$(x §$in A §$intersection §$p(A §$union B))(.) As also §$(x §$in A) by assumption, we have §$(x §$in A §$intersection §$p(A §$union B)) if and only if §$(x §$in A) in this case.
                  )
                )§p(
                  As the claim holds in every case, it holds in general.
                )§p(
                  For the sake of brevity, we omit the corresponding proof of §$(A §$union §$p(A §$intersection B) §$seq A).
                )
              )§li(
                §p(
                  The resulting proofs are rather long and uninspired compared to more natural proofs. They may be correct, but they convey little information about the structure of the problem at hand. Then again, even an uninspired proof is better than no proof at all. So do not be afraid to start slinging those §rs(case distinction) when you cannot make progress with a proof.
                )§p(
                  Even though the written form of these diagrams can feel clunky, many people find the diagrams themselves quite elegant. This is a remarkable testament to our ability to process visual information much more naturally than symbolic information. Many mathematicians think about problems in imagery, with the translation into written language as an almost incidental last step. Care must be taken however that the visualization is indeed an accurate representation of the problem; checking whether the visual information can be mechanically translated into a complete account of the situation in written language is a good habit to have.
                )
              )
            )
          )
        )

      )

      §hsection["section_set_difference"](Set Difference)(
        §p(
          §R(intersection) and §r(union) are arguably the two most simple operations on §rs(set), but sometimes they do not suffice. Consider, for example, the §r(set) of animal species that can swim but cannot fly. We cannot construct this set using §r(intersection) and §r(union) only. We thus define a third §r(binary operator):
        )

        §definition_marginalia(
          §venn_setdifference
        )(
          §definition["set_difference"](Set Difference)(
            §set_math_id["setminus", "set_difference"]
            §p(
              Let §$(A) and §$(B) be §rs(set).
            )
            §p(
              The §define(set difference) of §$(A) and §$(B)(,) §define(relative complement) of §$(B) in §$(A)(,) or simply §$(A) §define(without) §$(B)(,) written as §$(A §$define_notation(§$setminus) B)(,) is the §r(set) of all objects which are §rs(element) of §$(A) but not of §$(B)(:)

              §$$(
                A §$setminus B §$defeq §$set_builder(x)(§$text($x §$in A$ and $x §$notin B$)).
              )
            )
          )
        )

        §example["example_set_difference", "slightlywide"](Set Difference)(
          §input["euler_diagrams/setminus.html"]
        )

        §exercise["practice_set_difference_direct"](
          §p(
            Compute §span(practice_set_difference_direct_text)()()
          )

          §solution["practice_set_difference_direct"](
            §div(practice_set_difference_direct_solution)()()
          )
          §p(
            §button(practice_set_difference_direct_new)()(New Exercise)
          )
        )

        §p(
          Equipped with the notions of §r(intersection), §r(union), and §r(set difference), we can describe all the possible ways in which multiple §rs(set) can be combined:
        )

        §exercise["exercise_arbitrary_venn"](
          §p(
            Give an expression that denotes exactly the highlighted areas of the §r(Venn diagram) below. You will need at least §span(exercise_arbitrary_venn_text)()() operators.
          )

          §div(venn3_container centered)(
            §input["venn_diagrams/exercise_arbitrary.svg"]
          )

          §solution["exercise_arbitrary_venn"](
            §div(exercise_arbitrary_venn_solution)()()
          )
          §p(
            §button(exercise_arbitrary_venn_new)()(New Exercise)
          )
        )

        §p(
          An immediate observation we can make about the §r(set difference) operation is that removing elements from a §r(set) always results in a (not necessarily strict) §r(subset):
        )

        §proven_fact(
          §theorem["set_difference_nonincreasing"](
            §p(
              Let §$(A) and §$(B) be §rs(set). Then §$(A §$setminus B §$subseteq A)(.)
            )
          )
          §proof["set_difference_nonincreasing"](
            §p(
              Let §$(A) and §$(B) be §rs(set), and let §$(x) be an object. If §$(x §$in A §$setminus B)(,) then also §$(x §$in A) by definition of §$(§$setminus)(,) and thus §$(A §$setminus B §$subseteq A)(.)
            )
          )
        )

        §p(
          Unlike §r(intersection) and §r(union), §r(set difference) is sensitive to both the order of the two §rs(set) to be combined, and the grouping of multiple §rs(set difference).
        )

        §statement["set_difference_not_commutative"](
          §p(
            There exist §rs(set) §$(A) and §$(B) such that §$(A §$setminus B §$sneq B §$setminus A)(.)
          )

          §proof_as_exercise["set_difference_not_commutative"](
            §p(
              Define §$(A §$defeq §$set) and §$(B §$defeq §$set(§$symbol0))(.) Then §$$align*(
                A §$setminus B &§$seq §$set §$setminus §$set(§$symbol0)
              )(
                &§$seq §$set§ ,
              ) and §$$align*(
                B §$setminus A &§$seq §$set(§$symbol0) §$setminus §$set
              )(
                &§$seq §$set(§$symbol0),
              ) but §$(§$set §$sneq §$set(§$symbol0))(.)
            )
          )
        )

        §statement["set_difference_not_associative"](
          §p(
            There exist §rs(set) §$(A)(,) §$(B)(,) and §$(C) such that §$(§$p(A §$setminus B) §$setminus C §$sneq A §$setminus §$p(B §$setminus C))(.)
          )

          §proof_as_exercise["set_difference_not_associative"](
            §p(
              Define §$(A §$defeq §$set(§$symbol0))(,) §$(B §$defeq §$set)(,) and §$(C §$defeq §$set(§$symbol0))(.) Then §$$align*(
                §$p(A §$setminus B) §$setminus C &§$seq §$p[1](§$set(§$symbol0) §$setminus §$set) §$setminus §$set(§$symbol0)
              )(
                &§$seq §$set(§$symbol0) §$setminus §$set(§$symbol0)
              )(
                &§$seq §$set§ ,
              ) and §$$align*(
                A §$setminus §$p(B §$setminus C) &§$seq §$set(§$symbol0) §$setminus §$p[1](§$set §$setminus §$set(§$symbol0))
              )(
                &§$seq §$set(§$symbol0) §$setminus §$set
              )(
                &§$seq §$set(§$symbol0),
              ) but §$(§$set §$sneq §$set(§$symbol0))(.)
            )
          )
        )

        §p(
          When computing §rs(intersection) by hand, a helpful technique is to write down one of the §rs(set) and to then cross out the §rs(element) that do not occur in the other §r(set). An example: §$$(
            §$set(§$symbol0)(§$symbol1)(§$symbol3)(§$symbol4) §$intersection §$set(§$symbol0)(§$symbol2)(§$symbol3) §$seq §$set(§$symbol0)(§$cancel_symbol(§$symbol1))(§$symbol3)(§$cancel_symbol(§$symbol4)) §$seq §$set(§$symbol0)(§$symbol3).
          )

          We can prove that this technique always yields the correct result — take a moment to think through how the §cref(intersection_via_set_difference)(following theorem) relates to the technique:
        )

        §fact_marginalia(
          §venn_intersection_via_set_difference
        )(
          §proven_fact(
            §theorem["intersection_via_set_difference"](
              §p(
                Let §$(A) and §$(B) be §rs(set). Then §$(A §$intersection B §$seq A §$setminus §$p[1](A §$setminus B))(.)
              )
            )
            §proof["intersection_via_set_difference"](
              §proof_as_exercise["intersection_via_set_difference"](
                §p(
                  Let §$(A) and §$(B) be §rs(set), and let §$(x) be an object.
                )

                §proof_part(
                  §verbatim(§$(A §$intersection B §$subseteq A §$setminus §$p[1](A §$setminus B))):
                )(
                  §p(
                    Assume §$(x §$in A §$intersection B)(.) Then §$(x §$in B)(,) and thus §$(x §$notin A §$setminus B)(.) Since §$(x §$in A) (because §$(x §$in A §$intersection B)) and §$(x §$notin A §$setminus B)(,) we have that §$(x §$in A §$setminus §$p[1](A §$setminus B)) (by definition of §$(§$setminus)).
                  )
                )
                §proof_part(
                  §verbatim(§$(A §$intersection B §$supseteq A §$setminus §$p[1](A §$setminus B))):
                )(
                  §p(
                    Assume §$(x §$in A §$setminus §$p[1](A §$setminus B))(.) Then §$(x §$in A) by §cref(set_difference_nonincreasing), so it remains to show that §$(x §$in B)(.)
                  )§p(
                    Suppose toward a contradiction that §$(x §$notin B)(.) Then §$(x §$in A §$setminus B)(,) and thus §$(x §$notin A §$setminus §$p[1](A §$setminus B))(,) contradicting our initial assumption that §$(x §$in A §$setminus §$p[1](A §$setminus B))(.)
                  )
                )
              )
            )
          )
        )

        §p(
          We conclude the section with a few further exercises on §r(set difference).
        )

        §exercise["exercise_set_difference0"](
          §p(
            Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Prove that if §$(A §$subseteq B)(,) then §$(C §$setminus B §$subseteq C §$setminus A)(.)
          )

          §solution["exercise_set_difference0"](
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set), and let §$(x) be an object. Assume that §$(A §$subseteq B)(.) Then
            )
            §fleqn(
              §$$align*(
                x §$in C §$setminus B &§$implies §$text($x §$in C$ and $x §$notin B$) §$tag(§cref(set_difference)(Definition) $§$setminus§ $)
              )(
                &§$implies §$text($x §$in C$ and $x §$notin A$) §$tag($A §$subseteq B$, §R(contraposition))
              )(
                &§$implies x §$in C §$setminus A, §$tag(§cref(set_difference)(Definition) $§$setminus§ $)
              )
            )
            §p(
              and thus, §$(C §$setminus B §$subseteq C §$setminus A)(.)
            )
          )
        )

        §exercise["exercise_set_difference1"](
          §p(
            Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Prove that §$(B §$setminus A §$subseteq C) if and only if §$(B §$setminus C §$subseteq A)(.)
          )

          §solution["exercise_set_difference1"](
            §p(
              Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). We show the §rs(contrapositive) of both §rs(implication).
            )
            §proof_part(
              §verbatim(§$(B §$setminus C §$nsubseteq A §$implies B §$setminus A §$nsubseteq C))
            )(
              §p(
                Assume that §$(B §$setminus C §$nsubseteq A)(.) Then there exists §$(x §$in B §$setminus C) such that §$(x §$notin A)(.) By the definition of §$(§$setminus)(,) we know that §$(x §$in B) and §$(x §$notin C)(.)
              )§p(
                As §$(x §$in B) and §$(x §$notin A)(,) we have that §$(x §$in B §$setminus A)(.) Because §$(x §$notin C) however, we have that §$(B §$setminus A §$nsubseteq C)(.)
              )
            )
            §proof_part(
              §verbatim(§$(B §$setminus A §$nsubseteq C §$implies B §$setminus C §$nsubseteq A))
            )(
              §p(
                This part of the proof works fully analogously. Assume that §$(B §$setminus A §$nsubseteq C)(.) Then there exists §$(x §$in B §$setminus A) such that §$(x §$notin C)(.) By the definition of §$(§$setminus)(,) we know that §$(x §$in B) and §$(x §$notin A)(.)
              )§p(
                As §$(x §$in B) and §$(x §$notin C)(,) we have that §$(x §$in B §$setminus C)(.) Because §$(x §$notin A) however, we have that §$(B §$setminus C §$nsubseteq A)(.)
              )
            )
          )
        )

        §exercise_marginalia(
          §venn_exercise_set_difference2
        )(
          §exercise["exercise_set_difference2"](
            §ol(
              §li(
                §p(
                  Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Prove that §$(C §$setminus §$p(B §$setminus A) §$seq §$p(C §$intersection A) §$union §$p(C §$setminus B))(.)
                )
                §solution["exercise_set_difference2a"](
                  §p(
                    Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set), and let §$(x) be an object.
                  )
                  §proof_part(
                    §verbatim(§$(§$subseteq)):
                  )(
                    §p(
                      Assume that §$(x §$in C §$setminus §$p(B §$setminus A))(.) Then §$(x §$in C) and §$(x §$notin B §$setminus A)(.) We do a case §side(distinction)(Whenever you cannot make progress in a proof, try looking for a helpful case distinction. You then have §em(two) unfinished proofs to worry about, but both of them have stronger assumptions for you to work with.) over §r(member)(membership) of §$(x) in §$(B)(:)
                    )§cases(
                      §case(§$(x §$in B))(
                        §p(
                          If §$(x §$in B) while §$(x §$notin B §$setminus A)(,) we can conclude that §$(x §$in A)(.) Then §$(x §$in A §$intersection C)(,) and thus also §$(x §$in §$p(C §$intersection A) §$union §$p(C §$setminus B))(.)
                        )
                      )§case(§$(x §$notin B))(
                        §p(
                          If §$(x §$notin B)(,) then §$(x §$in C §$setminus B)(,) and then also §$(x §$in §$p(C §$intersection A) §$union §$p(C §$setminus B))(.)
                        )
                      )
                    )
                  )§proof_part(
                    §verbatim(§$(§$supseteq)):
                  )(
                    §p(
                      Assume that §$(x §$in §$p(C §$intersection A) §$union §$p(C §$setminus B))(.)
                    )§cases(
                      §case(§$(x §$in C §$intersection A))(
                        §p(
                          If §$(x §$in C §$intersection A)(,) then §$(x §$in C) and §$(x §$in A)(.) Because §$(x §$in A)(,) we have that §$(x §$notin B §$setminus A)(,) and thus §$(x §$in C §$setminus §$p(B §$setminus A))(.)
                        )
                      )§case(§$(x §$in C §$setminus B))(
                        §p(
                          If §$(x §$in C §$setminus B)(,) then §$(x §$in C) and §$(x §$notin B)(.) Because §$(x §$notin B)(,) we have that §$(x §$notin B §$setminus A)(,) and thus §$(x §$in C §$setminus §$p(B §$setminus A))(.)
                        )
                      )
                    )
                  )
                )
              )§li(
                §p(
                  How does §cref(intersection_via_set_difference) relate to this?
                )
                §solution["exercise_set_difference2b"](
                  §p(
                    §cref(intersection_via_set_difference) is the special case that occurs when §$(B §$seq C):
                  )§p(
                    Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set) with §$(B §$seq C)(.) Then
                  )
                  §fleqn(
                    §$$align*(
                      & C §$setminus §$p(§$highlightlowr1(B) §$setminus A) §$seq §$p(C §$intersection A) §$union §$p(C §$setminus §$highlightlow1(B))
                    )(
                      §$implies {} & C §$setminus §$p(§$highlighttopr1(C) §$setminus A) §$seq §$p(C §$intersection A) §$union §$highlightlow3(§$p(C §$setminus §$highlighttop1(C))) §$tag($B §$seq C$)
                    )(
                      §$implies {} & C §$setminus §$p(C §$setminus A) §$seq §$highlightlow5(§$p(C §$intersection A) §$union §$highlighttop3(§$set)) §$tag(§cref(set_difference)(Definition) $§$setminus§ $)
                    )(
                      §$implies {} & §$highlightlowr2(C §$setminus §$p(C §$setminus A)) §$seq §$highlightlow4(§$highlighttop5(C §$intersection A)) §$tag(§cref(union)(Definition) $§$union§ $)
                    )(
                      §$implies {} & §$highlighttopr4(§$highlightlowr6(C) §$intersection §$highlightlowr1(A)) §$seq §$highlighttop2(§$highlightlowr6(C) §$setminus §$p(§$highlightlowr6(C) §$setminus §$highlightlow1(A))) §$tag(§cref(seq_symmetry)(Symmetry $§$seq[true]$))
                    )(
                      §$implies {} & §$highlighttopr6(A) §$intersection §$highlighttopr1(B) §$seq §$highlighttopr6(A) §$setminus §$p(§$highlighttopr6(A) §$setminus §$highlighttop1(B)). §$tag(Rename)
                    )
                  )
                )
              )
            )
          )
        )

      )

    )

    §hsection["sets_of_sets"](Sets of Sets)(
      §p(
        With a solid understanding of the basic §rs(predicate) (§r(member)(membership), §r(seq)(equality), and being a (§r(strict subset)(strict)) §r(subset)) and §rs(binary operator)(operators) (§r(intersection), §r(union), and §r(set difference)) of set theory under our belt, we can now examine what makes §rs(set) so powerful.
      )§p(
        A §r(set) can contain arbitrary mathematical objects. A §r(set) is a mathematical object itself. See where this is going? §Rs(set) can contain other §rs(set)!
      )§p(
        We can have nested §rs(set) such as §$(§$set[2](§$set(§$symbol0)(§$symbol1))(§$set(§$symbol0)(§$symbol2))(§$symbol3)), and our §rs(predicate) work just as before: §$$align*(
          §$highlight1(§$set(§$symbol0)(§$symbol2)) &§$in §$set[2](§$set(§$symbol0)(§$symbol1))(§$highlight1(§$set(§$symbol0)(§$symbol2)))(§$symbol3) §$text(, and)
        )(
          §$set[2](§$highlight3(§$set(§$symbol0)(§$symbol1)))(§$highlight5_direct(§$symbol3)) &§$subseteq §$set[2](§$highlight3(§$set(§$symbol0)(§$symbol1)))(§$set(§$symbol0)(§$symbol2))(§$highlight5_direct(§$symbol3)).
        )
      )§p(
        Always stay mindful of the difference between the §rs(member) of a §r(set) and the §rs(member) of its §rs(member): §$(§$symbol0 §$notin §$set[2](§$set(§$symbol0)(§$symbol1))(§$set(§$symbol0)(§$symbol2))(§$symbol3))(,) even though §$(§$symbol0) is an §r(element) of some §rs(member) of §$(§$set[2](§$set(§$symbol0)(§$symbol1))(§$set(§$symbol0)(§$symbol2))(§$symbol3))(. )
      )§p(
        Another common source of mistakes is the distinction between an object and the §r(set) that contains exactly that object but nothing else. For each §r(set) §$(X) holds §$(§$set(X) §$sneq X)(,) because §$(X §$in §$set(X)) but §$(X §$notin X), as no §r(set) can be a §r(member) of itself. In particular, §$(§$set §$sneq §$set(§$set))(.) The §r(empty set) has no §rs(member), whereas §$(§$set(§$set)) has exactly one §r(member), namely the §r(empty set).
      )

      §exercise["nested_sets_predicates"](
        §p(
          Define §$(A §$defeq §$set(§$symbol0))(.) For each of the following subexercises, give a §r(set) §$(B) such that:
        )§ol(
          §li(§$(A §$notin B) and §$(A §$nsubseteq B)(.))
          §li(§$(A §$in B) and §$(A §$nsubseteq B)(.))
          §li(§$(A §$notin B) and §$(A §$subseteq B)(.))
          §li(§$(A §$in B) and §$(A §$subseteq B)(.))
        )

        §solution["nested_sets_predicates"](
          §ol(
            §li(
              §$(B §$defeq §$set)(.)
            )
            §li(
              §$(B §$defeq §$set[1](§$set(§$symbol0)))(.)
            )
            §li(
              §$(B §$defeq §$set(§$symbol0))(.)
            )
            §li(
              §$(B §$defeq §$set[1](§$symbol0)(§$set(§$symbol0)))(.)
            )
          )
        )
      )

      §p(
        Because we can nest §rs(set) arbitrarily deeply, we can represent even the most complex mathematical concepts through §rs(set). Sometimes we do so explicitly by defining the concepts in terms of §rs(set), sometimes we will simply assume implicitly that it would be possible to express concepts in terms of §rs(set). We have been using icons such as §$(§$symbol0§ , §$symbol1), and §$(§$symbol2) as objects, for example, but since their only interesting property is how they behave in terms of §r(equal)(equality), we might as well have been using the §rs(set) §$(§$set§ , §$set(§$set))(,) and §$(§$set(§$set(§$set))) instead. Using symbols is more readable, but ultimately not necessary from a purely mathematical §side(standpoint)(Expressing everything in terms of pure sets is indeed how more formal approaches to set theory eliminate the problem of having to define objects before being able to define sets.).
      )

      §hsection["section_powerset"](Power Sets)(
        §p(
          One particular kind of §r(set) of §rs(set) that we will encounter repeatedly throughout this book arises from the following question: Given some §r(set) §$(X), which §rs(set) are there that contain no objects but those from §$(X) (although not necessarily all of them)? This is in fact the same as asking for the §r(set) of §rs(subset) of §$(X) — take a moment to think through why that is. It is this viewpoint we use for our proper definition:
        )

        §definition["powerset"](Power Set)(
          §set_math_id["powerset", "powerset"]

          §p(
            Let §$(X) be a §r(set).
          )§p(
            The §define(power set) of §$(X)(,) written as §$(§$define_notation(§$powerset(§$text_color(X))))(,) is the §r(set) of all §rs(subset) of §$(X)(.)
          )
        )

        §example["example_powerset", "slightlywide"](Power Set)(
          §captioned(
            §input["euler_diagrams/powerset.html"]
          )(
            A visualization of the §r(power set) construction. The §r(empty set) is a §r(member) of every §r(power set), even though the §r(Euler diagram) never depicts it.
          )
        )

        §p(
          Notice how §verbatim(§$(A §$subseteq U)) and §verbatim(§$(A §$in §$powerset(U))) mean the same thing.
        )§p(
          The definition of §rs(power set) is very short, yet the §r(power set) of the §r(empty set) initially feels unintuitive to many learners. Think through the following two exercises however, and you should be fine.
        )

        §exercise["exercise_powerset_at_least"](
          §p(
            Find the mistake in the following claim: because the §r(empty set) is a §r(subset) of every §r(set) (§cref(empty_set_subset_everything)) and every §r(set) is a §r(subset) of itself (§cref(subseteq_reflexivity)), §$(§$powerset(X)) must contain at least two §rs(element) for each §r(set) §$(X)(.)
          )

          §solution["exercise_powerset_at_least"](
            §p(
              The argument ignores that the §r(empty set) and the §r(set) itself could be one and the same. And indeed, §$(§$powerset(§$set) §$seq §$set(§$set))(,) a §r(set) which only contains a single §r(element).
            )
          )
        )

        §exercise["exercise_powers_of_empty"](
          §p(
            Compute §$(§$powerset[2](§$powerset[1](§$powerset(§$set)))).
          )
          §solution["exercise_powers_of_empty"](
            §$$align*(
              & §$powerset[2](§$powerset[1](§$highlightlow1(§$powerset(§$set))))
            )(
              §$seq {} & §$powerset[2](§$highlightlow3(§$powerset[1](§$highlighttop1(§$set(§$set)))))
            )(
              §$seq {} & §$highlightlow5(§$powerset[2](§$highlighttop3(§$set[1](§$set§ , §$set(§$set)))))
            )(
              §$seq {} & §$highlighttop5(§$set[2](§$set§ , §$set(§$set), §$set[1](§$set(§$set)), §$set[1](§$set§ , §$set(§$set))))
            )
          )
        )

        §p(
          §Rs(power set) have a number of interesting properties, but for now it shall suffice to note that §rs(power set) are unique to each §side(§r(set))(A very different statement from the trivial observation that every §r(set) has exactly one §r(power set).):
        )

        §proven_fact(
          §theorem["equal_powersets_equal_sets"](
            §p(
              Let §$(A) and §$(B) be §rs(set). If §$(§$powerset(A) §$seq §$powerset(B))(,) then §$(A §$seq B)(.)
            )
          )
          §proof["equal_powersets_equal_sets"](
            §p(
              We do a proof by contraposition, that is, we show that if §$(A §$sneq B)(,) then §$(§$powerset(A) §$sneq §$powerset(B))(.) To that end, let §$(A) and §$(B) be §rs(set) with §$(A §$sneq B)(.)
            )§p(
              Without loss of generality, there exists §$(a §$in A) such that §$(a §$notin B) §parens(otherwise)(switch the roles of §$(A) and)(§$(B)). Then §$(§$set(a) §$in §$powerset(A)) §(because §$()(§$set(a) §$subseteq A)(§)) but §$(§$set(a) §$notin §$powerset(B)) §(because §$()(§$set(a) §$nsubseteq B)(§),) and thus, §$(§$powerset(A) §$sneq §$powerset(B))(.)
            )
          )
        )

        §p(
          The proof of §cref(equal_powersets_equal_sets) contains the handy phrase §verbatim(without)(loss of)(generality), which indicates that only one of several distinct cases will be presented, because the other cases work in a similar way and can be handled through simple modifications to the presented argument. In this example, it is clearly not always true that §$(A) has a §r(member) that is not §r(in) §$(B)(,) as §$(A) could be a §r(strict subset)((strict) subset) of §$(B)(.) But in that case, simply renaming §$(A) to §verbatim(§$(B)) and vice versa correctly finishes the proof.
        )§p(
          Quickly jotting down a §verbatim(without)(loss of)(generality) (or §verbatim(w.l.o.g.) for the particularly time-pressed mathematician) can often lead to overlooking crucial corner cases, resulting in faulty proofs. Whenever you feel tempted to §side(wlog)(It may not have been a verb before, but now it is.) your way out of a lengthy proof, ask yourself whether you can describe the necessary changes to cover all cases in one sentence. If you can, then simply add that sentence to your proof. And if you cannot, then you do not get to drop those convenient four words.
        )

      )

    )

    §hsection["conclusion_sets"](Conclusion)(
      §p(
        This concludes our first foray into set theory. Almost all of modern §side(mathematics)(Alternate formalisms that can serve as foundations of mathematics include §link(category theory)(https://en.wikipedia.org/wiki/Category_theory) and §link(type theories)(https://en.wikipedia.org/wiki/Type_theory). Set theory however is by far the most widely used one, both in teaching and in actual research.) builds upon the notion of §rs(set), with its §rs(predicate) of §r(member)(membership), §r(seq)(equality), and §rs(subset), and the operations of §r(intersection), §r(union), §r(set difference), and §r(power set).
      )§p(
        By now, you should have developed a solid intuitive understanding of these §rs(predicate) and operations. You should also be able to work with their formal definitions and prove statements that relate them to each other.
      )§p(
        The proofs in this chapter rarely required a brilliant idea, but rather demonstrated the basic workflow of breaking down definitions and letting the structure of the statements in question guide the proof. This alone will get you quite far, a significant part of mathematics is solid, unexciting craftsmanship. It might not be glamorous, but it yields good results.
      )§p(
        Throughout the examples and exercises of this chapter, all specific §rs(set) contained finitely many §rs(element). The definition of §rs(set) does not require this, it is perfectly fine for a §r(set) to contain infinitely many objects. All our proofs work perfectly fine for infinite §rs(set). Infinite §rs(set) come with their own challenges however, starting with the simple question of how to even define an infinitely large object through a finite mathematic expression. The answers to that and several other problems are what we will cover in the §cref(chapter_induction)(next chapter).
      )
    )

    §hsection["exercises_sets"](Exercises)(
      §p(
        This section contains a collection of exercises that touch upon all definitions of this chapter. Some introduce new but related definitions, so make sure to read through the exercises even if you do not intend to solve all of them. Unlike the exercises throughout the chapter body, these exercises do not come with solutions. Write your own instead, and try to get feedback on them.
      )

      §exercise["exercise_cardinality_constraints"](
        §ol(
          §li(
            §p(
              Give §rs(set) §$(A)(,) §$(B)(,) and §$(C) such that all of the following conditions are satisfied simultaneously:
            )§ol(
              §li(§$(A) has exactly five §rs(element),)
              §li(§$(B) has exactly three §rs(element),)
              §li(§$(C) has at least as many §rs(element) as §$(A §$setminus B),)
              §li(§$(A §$union B) has exactly seven §rs(element),)
              §li(§$(B §$intersection C) has exactly two §rs(element), and)
              §li(§$(A §$setminus C) has exactly three §rs(element).)
            )
          )§li(
            §p(
              Give §rs(set) §$(D, E, F) such that all of the following conditions are satisfied simultaneously:
            )§ol(
              §li(§$(D §$subset E)(,))
              §li(§$(§$powerset(D) §$intersection F) has exactly two §rs(element),)
              §li(§$(E §$setminus F) has exactly two §rs(element), and)
              §li(§$(F §$in D).)
            )
          )
        )
      )

      §exercise["exercise_sets_solve"](
        §ol(
          §li(
            Find a §r(set) §$(X) such that §$(§$p(X §$setminus §$set(0)(2)) §$intersection §$p(X §$union §$set(0)(1)) §$seq §$set(0)(2) §$setminus X)(.) Justify your answer by giving the step-by-step computations of the expressions.
          )§li(
            Prove that your answer is the only possible §side(solution)(Figuring out how to prove uniqueness of the solution is the interesting part of this exercise.).
          )§li(
            Invent your own exercises of this kind: one with exactly one solution, one with exactly two solutions, one with infinitely many solutions, and one with no §side(solutions)(For each of these you have to prove that your equation has the desired number of solutions.).
          )
        )
      )

      §theorem["subset_subseteq_transitive"](
        §p(
          Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set).
        )§ol(
          §li(
            If §$(A §$subseteq B) and §$(B §$subset C)(,) then §$(A §$subset C)(.)
          )§li(
            If §$(A §$subset B) and §$(B §$subseteq C)(,) then §$(A §$subset C)(.)
          )
        )
      )
      §exercise["exercise_subset_subseteq_transitive"](
        §p(
          Prove §cref(subset_subseteq_transitive).
        )
      )

      §exercise["exercise_set_operations_extremes"](
        §p(
          Let §$(U) be a §r(set), and let §$(A §$subseteq U). For each of the following equations, give a §r(set) §$(B) that satisfies the equation, or prove that no such §$(B) §side(exists)(
            Keep in mind that §$(U) and §$(A) are §r(universal quantification)(universally quantified), so it is not sufficient to give a §r(set) §$(B) that only works for special choices of §$(U) and §$(A)(.) You can however define §$(B) in terms of §$(U) and §$(A)(,) for example, §lquote§ Define §$(B §$defeq U §$setminus A)(§rquote§ .)
          ).
        )

        §ol(
          §li(
            §$(A §$intersection B §$seq U)(,)
          )
          §li(
            §$(A §$intersection B §$seq A)(,)
          )
          §li(
            §$(A §$intersection B §$seq §$set)(,)
          )
          §li(
            §$(A §$union B §$seq U)(,)
          )
          §li(
            §$(A §$union B §$seq A)(,)
          )
          §li(
            §$(A §$union B §$seq §$set)(,)
          )
          §li(
            §$(A §$setminus B §$seq U)(,)
          )
          §li(
            §$(A §$setminus B §$seq A)(,)
          )
          §li(
            §$(A §$setminus B §$seq §$set)(.)
          )
        )
      )

      §theorem["distributivity_intersection_union"](Distributivity of §$(§$intersection[true]) and §$(§$union[true]))(
        §p(
          Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Then
        )

        §ol(
          §li(
            §$(A §$intersection §$p(B §$union C) §$seq §$p(A §$union B) §$intersection §$p(A §$union C))(,) and
          )§li(
            §$(A §$union §$p(B §$intersection C) §$seq §$p(A §$intersection B) §$union §$p(A §$intersection C))(.)
          )
        )
      )

      §exercise["exercise_distributivity_intersection_union"](
        §p(
          Prove §cref(distributivity_intersection_union).
        )
      )

      §exercise["exercise_set_difference3"](
        §p(
          Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Prove that §$(§$p(B §$setminus A) §$union C §$seq §$p(B §$union C) §$setminus §$p(A §$setminus C))(.)
        )
      )

      §exercise["exercise_powerset_lift"](
        §p(
          Let §$(A) and §$(B) be §rs(set). Prove or disprove:
        )
        §ol(
          §li(
            §$(§$powerset(A) §$union §$powerset(B) §$seq §$powerset(A §$union B))(,)
          )§li(
            §$(§$powerset(A) §$intersection §$powerset(B) §$seq §$powerset(A §$intersection B))(.)
          )
        )
      )

      §definition_marginalia(
        §venn_symmetric_difference
      )(
        §definition["symmetric_difference"](Symmetric Difference)(
          §set_math_id["symdif", "symmetric_difference"]
          §p(
            Let §$(A) and §$(B) be §rs(set).
          )§p(
            The §define(symmetric difference) of §$(A) and §$(B)(,) written as §$(A §$define_notation(§$symdif) B)(,) is the §r(set) of all objects which are §rs(element) of exactly one of §$(A) or §$(B)(:)

            §$$(
              A §$symdif B §$defeq §$p(A §$setminus B) §$union §$p(B §$setminus A).
            )
          )
        )
      )

      §exercise["exercise_symdif_compute"](
        §p(
          Compute §$(§$set(0)(2)(3) §$symdif §$p[2](§$p[1](§$set(0)(2)(3) §$symdif §$set(0)(4)) §$symdif §$set(1)(3)(4))) step by step. If you did everything correctly, the final result should be §$(§$set(0)(1)(3))(.)
        )
      )

      §theorem["commutative_symdif"](Commutativity of §$(§$symdif[true]§ ))(
        §p(
          Let §$(A) and §$(B) be §rs(set). Then §$(A §$symdif B §$seq B §$symdif A)(.)
        )
      )
      §exercise["exercise_commutative_symdif"](
        §p(
          Prove §cref(commutative_symdif).
        )
      )

      §exercise["exercise_symdif_venn"](
        §p(
          Draw a §r(Venn diagram) of three §rs(set) §$(A)(,) §$(B)(,) and §$(C)(,) and highlight the areas corresponding to §$(§$p(A §$symdif B) §$symdif C)(.)
        )
      )

      §theorem["associative_symdif"](Associativity of §$(§$symdif[true]§ ))(
        §p(
          Let §$(A)(,) §$(B)(,) and §$(C) be §rs(set). Then §$(§$p(A §$symdif B) §$symdif C §$seq A §$symdif §$p(B §$symdif C))(.)
        )
      )
      §exercise["exercise_associative_symdif"](
        §p(
          Prove §cref(associative_symdif).
        )
      )

      §theorem["characterization_symdif"](
        §p(
          Let §$(A) and §$(B) be §rs(set). Then §$(A §$symdif B §$seq §$p(A §$union B) §$setminus §$p(A §$intersection B))(.)
        )
      )
      §exercise["exercise_characterization_symdif"](
        §p(
          Prove §cref(characterization_symdif).
        )
      )

    )

    §chapternav

  )
)
