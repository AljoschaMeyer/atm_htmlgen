§template(

)(
  §hsection(chapter_deductive_reasoning)(Deductive Reasoning)(
    §p(
      Mathematicians go about understanding the world in a very rigorous manner; they do not §em(guess) or §em(believe) things, but they §em(prove) them. Once a fact has been proven, it can be used for proving other facts. In this chapter, we take a close look at how to operate in this framework. As a human being, you are already adept at reasoning about the world, so some of what follows will likely be familiar to you already. Turning your intuitive understanding into explicit knowledge will improve your ability to reason this way.
    )

    §hsection(section_deductive_reasoning)(Gathering Knowledge)(
      §p(
        §define["deductive_reasoning"](deductive reasoning)(deductive reasonings)(Deductive reasoning) is the process of concluding facts from assumptions. If we assume that squirrels are always hungry, and that Alex is a squirrel, we can conclude that Alex is always hungry. A framework for §r(deductive reasoning) must provide clear rules on which deduction steps are valid. If, for example, we knew that Vic was always hungry, we should not be able to conclude that Vic is a squirrel; Vic could be a badger for all we know.
      )§p(
        Contrast this with §define["inductive_reasoning"](inductive reasoning), the process of hypothesizing causes from observed facts. From observing that the sun rises and sets every day, you might form the potential explanation that the sun orbits the earth. Later observations might invalidate a hypothesis, but a hypothesis can never be proven beyond doubt.
      )§p(
        Even though §r(inductive reasoning) can lead to false conclusions, it has its firm place in humanity's quest for knowledge. Physics or chemistry, for example, would make little sense if they were not grounded in observations of the world around us. They can strive to find increasingly accurate models of the world, but there can always be a new experiment that contradicts the existing models.
      )§p(
        Unlike the natural sciences, mathematics thus relies on §r(deductive reasoning) alone. Rigorous adherence to the principle that every claim has to follow from either assumptions or previously proven claims may not be a normal mode of operation for your brain, but learning to operate that way comes with a number of benefits:
      )§ul(
        §li(
          Proven knowledge is permanent. It does not degrade, it does not go out of style, it will not be falsified by a future experiment. This has enabled mathematicians to build up knowledge over centuries.
        )
        §li(
          Proven knowledge is verifiable. It does not matter who wrote a proof, whether you trust them or not. If every single step follows the deduction rules, then the resulting information is true.
        )
        §li(
          Proven knowledge is inspectable. If you do not understand why something is true, the proof breaks it down for you into small, almost obviously correct steps. More often than not, the person who wrote that initially incomprehensible proof is yourself from the past. But if the proof is well written, you are always able to untangle it.
        )
        §li(
          Proven knowledge is composable. Once a fact has been proven, it can be reused in further proofs. Furthermore, the details of how it was proven do not affect that reuse in any way.
        )
      )§p(
        Once mastered, §r(deductive reasoning) enables you to think thoughts you would not have been able to think otherwise, because you would have been overwhelmed by the sheer amount of details and the accumulation of tiny errors.
      )§p(
        A key property of §r(deductive reasoning) is that the mere form of a statement already implies how it can be proven. Suppose we want to prove that there is at least one hungry badger, how do we go about it? By presenting an actual hungry badger. How do you prove that there is at least one flying squirrel? By presenting an actual flying squirrel. If however we wanted to prove that all squirrels can fly, presenting an individual flying one would not help at all.
      )§p(
        Consequently, the fewer different forms of statements there are, the less complicated the system of §r(deductive reasoning) becomes. In the next section, we examine a small number of constructs for forming statements, chosen so that any statement of interest can be expressed using these constructs. The accompanying examples may feel trivial or even boring in their simplicity. That is an incredibly important and desired aspect of the system. Proving facts should not in itself be difficult; all complexity should come from the subject matter at hand, not the proof mechanism itself. Humanity has expended a great deal of collective brainpower so that the contents of the following section would become as simple as possible.
      )

    )

    §hsection(section_whirlwind_tour)(A Whirlwind Tour of Tiny Proofs)(
      §p(
        In order to formulate statements, we first need objects that the statements can talk about. For the coming examples, we will primarily use the natural numbers (§$(0, 1, 2, §$ldots)). To demonstrate that this mode of reasoning can be applied to anything really, we will also talk about a population of friendly (and hungry) squirrels: §$(§$value(Alex)), §$(§$value(Blake)), and §$(§$value(Charlie)).
      )§p(
        A squirrel by itself is not a statement; §$(§$value(Alex)) is neither true nor false, but merely an adorable object of interest. The same applies to the number §$(17), although arguably less adorable. We can bridge into the world of statements by comparing objects for equality:
      )§definition["eq"](Equality)()(
        §set_math_id["eq", "eq"]
        §p(
          Two objects are considered §define["equal"](equal) if they are identical: everything is equal to itself, but not equal to anything else. Claiming that two objects are §r(equal) is a statement. We write §verbatim(§$(x §$eq y)) to compactly express that the object §$(x) is §r(equal) to the object §$(y).
        )
      )

      §p(
        Now we established enough concepts to look at a first statement and a proof of it.
      )

      §statement["tour_equality"](
        §p(§$(17 §$eq 17).)
      )(
        §p(The claim holds by the §r(equal)(definition of equality).)
      )

      §p(
        Though rather unexciting, this is our first real proof. Introducing the concept of §r(equal)(equality) would be rather pointless if we could not immediately determine whether any two objects are §r(equal) or not.
      )§p(
        We can make things slightly more interesting by adding §definex["tour_def_term"](term)(terms)(terms)(
          A §rdef(term) denotes a way of obtaining objects of interest from other objects or other §rs(term). In our examples, §verbatim(§$(+)) denotes addition of two numbers.
        ) such as §$(1 + 2) to our language of statements. A §r(term) always denotes a way of obtaining objects of interest from other objects or other §rs(term). In our examples, §verbatim(§$(+)) denotes addition of two numbers.
      )

      §statement["tour_terms"](
        §p(§$(5 + 12 §$eq 17).)
      )(
        §p(§$(5 + 12) is §$(17), and §$(17 §$eq 17) by the §r(equal)(definition of equality).)
      )

      §p(
        Introducing §rs(term) still does not add any real depth however: after evaluating the §rs(term), their §r(equal)(equality) also either does or does not hold by definition. To formulate and prove more meaningful statements, we need the ability to define statements whose truth depends on the truth of other statements.
      )

      §hsection(quantifiers)(Quantifiers)(
        §p(
          The first such statements we examine are those of §definex["existential_quantification"](existential quantification)(
            §p(
              A statement of §rdef(existential quantification) asserts that there exists at least one object satisfying a certain property: §verbatim(There exists a natural number §$(n) such that §$(n = 17)).
            )§p(
              You prove a statement of §r(existential quantification) by presenting a §r(witness), that is, an object that satisfies the required property: §verbatim(Define §$(n §$defeq 17), then §$(n §$eq n)).
            )
          ), which is just fancy terminology for stating that at least one object satisfying a certain property exists:
        )

        §statement["tour_existential_quantification"](
          §p(There exists a squirrel §$(s) such that §$(s §$eq §$value(Alex)).)
        )(
          §p(Define §$(s §$defeq §$value(Alex)), then §$(s §$eq §$value(Alex)).)
        )

        §p(
          You prove §r(existential quantification)(statements of this form) by presenting a §definex["witness"](witness)(witnesses)(
            §p(A §rdef(witness) for a statement of §r(existential quantification) is an object for which the quantified claim holds.)
          ), that is, an object that satisfies the required property. Note how two symbols that looks similar but have completely different meaning appear in the proof: §verbatim(§$(§$eq)) signifies a statement that is true if both sides of the sign denote the same object, whereas §definex["defeq"](defeq)()()(
            §p(The §verbatim(§$(§$defeq)) symbol makes the name on its left denote the object on its right: §verbatim(Define §$(x §$defeq 42), then §$(x §$eq 42)).)
          )§set_math_id["defeq", "defeq"]§set_math_id["eqdef", "defeq"]§verbatim(§$(§$defeq)) makes the name on the left side denote the object on the right side.
        )§p(
          As §r(existential quantification) results in statements about statements, we can formulate statements with multiple, nested levels of quantification:
        )

        §statement["tour_existential_quantification_nested"](
          §p(There exists a squirrel §$(s) such that there exists a squirrel §$(t) such that §$(s §$eq t).)
        )(
          §p(Define §$(s §$defeq §$value(Charlie)) and §$(t §$defeq §$value(Charlie)), then §$(s §$eq t).)
        )

        §exercise["tour_existential_quantification_atleast"](
          §p(
            When mathematicians say §verbatim(there exists an object) they mean §verbatim(there exists at least one object, and there may or may not be more). Why is that, and why is it not necessary to say so explicitly?
          )
        )

        §p(
          Besides §r(existential quantification) for asserting that a statement holds for at least one object, there is §definex["universal_quantification"](universal quantification)(
            §p(
              A statement of §rdef(universal quantification) asserts that all objects satisfy a certain property: §verbatim(For all natural numbers §$(n) it holds that §$(n §$eq n)).
            )§p(
              You prove a statement of §r(universal quantification) by showing that an arbitrarily chosen object satisfies the required property: §verbatim(Let §$(n) be a natural number. Then §$(n §$eq n)).
            )
          ) for asserting that a statement holds for all objects:
        )

        §statement["tour_universal_quantification"](
          §p(For all natural numbers §$(n) it holds that §$(n §$eq n).)
        )(
          §p(Let §$(n) be a natural number. Then §$(n §$eq n) by the §r(equal)(definition of equality).)
        )

        §p(
          Because there are infinitely many natural numbers, we cannot prove a statement about every single number by going through all of them; we need our proofs to be of finite size. The only way to prove statements of §r(universal quantification) is by showing that the property in question holds for an arbitrarily chosen object, one about which we know nothing except that it is the kind of object that the statement speaks of. Throughout the book, we always use the phrase §verbatim(Let §$(x) be a §i(something).) to express when this is happening. Proving statements by working with arbitrarily chosen, featureless objects usually takes some getting used to, but it is the only way of making meaningful statements about infinitely many objects.
        )§p(
          The phrase §verbatim(Let §$(x) be a §i(something).) is also sometimes used as a different way of phrasing statements of §r(universal quantification), namely to specify in advance which kinds of objects a statement will talk about. The following example expresses exactly the same fact as §cref(tour_universal_quantification) (and thus admits an identical proof), merely formulated differently:
        )

        §statement["tour_assumptions"](
          §p(Let §$(n) be a natural number.)
        )(
          §p(§$(n §$eq n).)
        )(
          §p(Let §$(n) be a natural number. Then §$(n §$eq n) by the §r(equal)(definition of equality).)
        )

      )

      §hsection(definitions)(Definitions)(
        §p(
          §R(existential quantification) and §r(universal quantification) enable us to define a more interesting relation between numbers than equality:
        )

        §definition["leq"](
          §p(
            Let §$(n) and §$(m) be natural numbers.
          )
        )(
          §set_math_id["leq", "leq"]
          §p(
            We say that §$(n) is §define(less than or equal to) §$(m), written as §$(n §$leq m), if there exists a natural number §$(k) such that §$(n + k §$eq m).
          )
        )

        §p(
          With this concept defined, we can formulate statements about numbers being §r(less than or equal to) other numbers:
        )

        §statement["tour_leq"](
          §p(There exists a natural number §$(n) such that §$(n §$leq 17).)
        )(
          §p(
            Define §$(n §$defeq 12). Then §$(n §$leq 17) if there exists a natural number §$(k) such that §$(n + k §$eq 17).
          )§p(
            Define §$(k §$defeq 5). Then §$$align*(n + k &§$eq 12 + 5)(&§$eq 17,) and thus §$(n §$leq 17).
          )
        )
        §statement["tour_leq2"](
          §p(Let §$(n) be a natural number.)
        )(
          §p(§$(n §$leq n).)
        )(
          §p(
            Define §$(k §$defeq 0). Then §$$align*(n + k &§$eq n + 0)(&§$eq n,) and thus §$(n §$leq n).
          )
        )

        §p(
          As you can see, a definition is nothing but a shorthand; proofs proceed by unfolding the definition and then continuing as if the body of the definition had been used rather than its shorter name. Naming recurring concepts is vital to achieving concise yet precise communication, and it can also help in clarifying thought processes. This can lead to short sentences carrying large amounts of information, but this information can always be recovered by repeatedly unfolding definitions.
        )§p(
          This book tries to make the unfolding of definitions as easy as possible: you can hover over any defined terminology (for example, §verbatim(§r(less than or equal to))) or symbol (for example, §verbatim(§$(§$leq))), and the definition will open in a tooltip. The terminology or symbol is also a hyperlink to its definition.
        )

        §exercise["exercise_tour_leq"](
          §p(Prove that for all natural numbers §$(n) it holds that §$(0 §$leq n).)
        )

        §p(
          Originally, §r(equal)(equality) was our only way of moving from objects of interest to statements of truth: §$(17) is not a statement (it is neither true nor false), but §$(17 §$eq 18) is (albeit a false one). The newly defined concept of numbers being §r(less than or equal to) each other achieves the same lift of conceptual level. Notice that its definition ultimately relies on §r(equal)(equality) again. Every such definition can ultimately be broken down to the level of §r(equal)(equality) comparisons again.
        )§p(
          Aside from introducing new concepts like this, we can also define new §rs(term), that is, new ways of compactly describing objects of interest based on other objects:
        )

        §definition["twice"](
          §p(
            Let §$(n) be a natural number.
          )
        )(
          §set_math_id["twice", "twice"]
          §p(
            We denote by §$(§$twice(n)) the number §$(n + n).
          )
        )
        §statement["tour_twice"](
          §p(
            There exists a natural number §$(n) such that §$(§$twice(n) §$eq n).
          )
        )(
          §p(
            Define §$(n §$defeq 0), then §$$align*(
              §$twice(n) &§$eq n + n
            )(
              &§$eq 0 + 0
            )(
              &§$eq 0
            )(
              &§$eq n.
            )
          )
        )

      )

      §hsection(utilizing_quantification)(Utilizing Quantifications)(
        §p(
          Once a statement of §r(universal quantification) has been proven, the acquired knowledge can be used in other proofs:
        )

        §statement["use_universal"](
          §p(§$(5 §$leq 5).)
        )(
          §p(§$(5) is a natural number. Thus, by §cref(tour_leq2), §$(5 §$leq 5).)
        )

        §p(
          It would not have been difficult to prove §cref(use_universal) directly, but utilizing §cref(tour_leq2) saved us the trouble of finding a suitable number §$(k) to add to §$(5). In fact, our proof works even if we have no idea how §verbatim(§$(§$leq)) is defined. This hints at one of the key strengths of §r(deductive reasoning): we can reason in terms of high-level concepts (§verbatim(§$(§$leq))) while still getting the guarantee that everything works because it can ultimately be broken down to simple and correct building blocks (§r(equal)(equality) and §r(existential quantification)).
        )

        §p(
          Using a statement of §r(existential quantification) is less straightforward, because you merely know that some §r(witness) satisfying a certain property exists, but you do not know anything else about that §r(witness). Thus you cannot utilize any further properties of the §r(witness) in your proof.
        )

        §statement["use_existential"](
          §p(There exists a natural number §$(n) such that §$(n §$leq 18).)
        )(
          §p(
            By §cref(tour_leq), there exists §$(n) such that §$(n §$leq 17). We thus know about this §$(n) that there exists §$(k) such that §$(n + k §$eq 17), and this is in fact all we §em(can) know about it.
          )§p(
            If §$(n + k §$eq 17), then also §$(§$p(n + k) + 1 §$eq 17 + 1), then also §$(§$p(n + k) + 1 §$eq 18), and then also §$(n + §$p(k + 1) §$eq 18).
          )§p(
            §$(k + 1) is a natural number, so we have found a number that we can add to §$(n) to obtain §$(18). Or in other words, we have proven that §$(n §$leq 18).
          )
        )

        §p(
          Compared to directly choosing a suitable §$(n), this proof is of course needlessly complicated. But it demonstrates how to work with this number §$(n) that we know very little about. There are 18 different numbers which are possible candidates for this §$(n), each of them with unique properties not shared by any other number. Most of these properties are completely unrelated to the proof at hand.
        )§p(
          If we worked with any specific number, we might be distracted by its properties. By working with the abstract value §$(n) that we obtained from §cref(tour_leq) however, only the relevant property of being §r(less than or equal to) §$(17) is available to our reasoning, which protects us from losing ourselves in irrelevant details.
        )

        §p(
          You can argue that knowing a statement of §r(universal quantification) is more useful than knowing a statement of §r(existential quantification), because it can be more readily used in further proofs. This is offset by the fact that statements of §r(existential quantification) are much easier to prove — providing a specific §r(witness) is easier than working with abstract values which can represent any number of specific values.
        )§p(
          Interestingly enough, you can also take on a completely opposite view. What is interesting about properties that hold for every single object there is? §R(existential quantification) conveys the actually useful facts, it talks about the hidden gems among the masses of uninteresting objects. Unfortunately, these statements are much more difficult to prove — you need a clever idea for finding an object with the desired properties, rather than being handed an uncomplicated, distraction-free, abstract value to work with.
        )

        §exercise["existential_vs_universal"](
          §p(
            Try to pinpoint the two different definitions of §verbatim(usefulness) and §verbatim(difficulty) respectively that lead to the preceding two lines of reasoning. Which definitions do you think are more appropriate?
          )
        )

      )

      §hsection(names)(Names)(
        §p(
          At this point, we should briefly discuss §definex(name)(names)(names)(
            §p()
          ), which we have started using in §rs(term) such as §verbatim(§$(n + k §$eq 17)) without prior discussion. §Rs(name) can stand in for objects or §rs(term), but they never drop out of nowhere. Every §r(name) has to be introduced before it can appear in a proof: If we have no idea what §$(x) is, how are we to determine whether §$(x §$eq 6) is true or false?
        )§p(
          There is only a limited number of ways in which §rs(name) can be introduced, and we have already seen all of them:
        )§ul(
          §li(
            Formulating §rs(universal quantification): §verbatim(For all squirrels §$(s) it holds that…).
          )§li(
            Proving §rs(universal quantification): §verbatim(Let §$(s) be a squirrel, then…).
          )§li(
            Formulating §rs(existential quantification): §verbatim(There exists a squirrel §$(s) such that…).
          )§li(
            Proving §rs(existential quantification): §verbatim(Let §$(s) be a squirrel such that…).
          )§li(
            §R(defeq)(Naming) §rs(term): §verbatim(Define §$(s §$defeq §$ldots)).
          )
        )
        §p(
          Each time you see a §r(name), and each time you use one yourself, it must have been introduced by exactly one of these constructs (or an equivalent wording expressing the same notion).
        )§p(
          §R(name) introductions usually make the §r(name) available up until the end of the current text component, for example, until the end of the current statement, definition, (sub-)exercise, and so on. That is why the statements in this chapter quantify §$(n) again and again.
        )

      )

    §hsection(quantifier_order)(Quantifier Order)(
      §p(
        Does it matter in which order the quantifications of a statement occur? It does not for nested §rs(existential quantification) such as those of §cref(tour_existential_quantification_nested): It makes no difference in which order we define the §rs(witness), so the same proofs still work if the order of the quantifications in the statement is swapped. The same as the case for nested statements of §r(universal quantification), the order in which we obtain the featureless values for which to prove the desired properties does not matter for the prove to be correct.
      )

      §p(
        When interleaving §r(existential quantification) and §r(universal quantification) however, the quantifier order matters, as exemplified by the following statement:
      )

      §statement["tour_order"](
        §p(For all natural numbers §$(n) there exists a natural number §$(m) such that §$(n §$eq m).)
      )(
        §p(
          Let §$(n) be a natural number. Define §$(m §$defeq n). Then §$(n §$eq m).
        )
      )

      §p(
        §cref(tour_order)(This statement) is true, but what happens if we swap the order of the quantifiers?
      )

      §falsehood["tour_order2"](
        §p(There exists a natural number §$(m) such that for all natural numbers §$(n) we have §$(n §$eq m).)
      )(
        §p(???)
      )

      §cref(tour_order2) is clearly different from §cref(tour_order), there certainly is no number that is §r(equal) to every number. But how do we disprove a statement? For that, we need to examine the concept of negated statements.
    )

    §hsection(negations)(Negation)(
      §p(
        The §definex["negation"](negation)(
          §p(
            A §rdef(negation) asserts that another statement does not hold.
          )§p(
            You prove a §r(negation)(negated) statement depending on the kind of statement that is being §r(negation)(negated).
          )
        ) of a statement is a new statement that is true if the old statement is false, and vice versa. Or in other words, a §r(negation) asserts that another statement does not hold. How do we prove a §r(negation)(negated) statement? That depends on the kind of statement that is being §r(negation)(negated). The easiest case is that of an §r(equal)(equality), whose truth can be derived directly by definition:
      )

      §statement["tour_negation_eq"](
        §p(It does not hold that §$(5 §$eq 6).)
      )(
        §p(§$(5 §$eq 6) does not hold by §r(equal)(the definition of equality), so the §r(negation) of §$(5 §$eq 6) does hold.)
      )

      §p(
        Another easy case is that of a §r(negation)(negated) §r(negation) (a §definex["double_negation"](double negation)(A §rdef(double negation) is the §r(negation) of a §r(negation).)), which is simply canceled out.
      )

      §statement["tour_negation_negation"](
        §p(It does not hold that it does not hold that §$(5 §$eq 5).)
      )(
        §p(
          The statement that remains after eliminating the §r(double negation) is §$(5 §$eq 5), which holds by §r(equal)(the definition of equality).
        )
      )

      §p(
        More interesting are §rs(negation) of quantifications. If a statement does not hold for all objects, then there has to exist a counterexample. In other words, we can prove the §r(negation) of a statement of §r(universal quantification) by changing it to §r(existential quantification) and moving the §r(negation) past the quantifier:
      )

      §statement["tour_negation_universal"](
        §p(It does not hold for all squirrels §$(s) that §$(s §$eq §$value(Alex)).)
      )(
        §p(
          We can prove the statement by showing that there exists a squirrel §$(s) such that it does not hold that §$(s §$eq §$value(Alex)). Define §$(s §$defeq §$value(Blake)), then it does not hold that §$(s §$eq §$value(Alex)).
        )
      )

      §p(
        Conversely, if no object satisfying a property exists, then all objects do not satisfy that property. That is, we can prove the §r(negation) of a statement of §r(existential quantification) by changing it to §r(universal quantification) and moving the §r(negation) past the quantifier.
      )

      §statement["tour_negation_existential"](
        §p(It does not hold that there exists a squirrel §$(s) such that it does not hold that §$(s §$eq s).)
      )(
        §p(
          We can prove the statement by showing that for all squirrels §$(s) it does not hold that it does not hold that §$(s §$eq s). Let §$(s) be a squirrel. Then §$(s §$eq s), which is exactly what remains to be proven after the §r(double negation) has been eliminated.
        )
      )

      §p(
        §Rs(negation) are usually formulated less verbosely, for example §verbatim(It does not hold that there exist §$(x) such that…) would normally be written along the lines of §verbatim(There exists no §$(x) such that…). The negation of statements of §r(equal)(equality) even has its own symbol: if §$(x) and §$(y) are §definex["neq"](unequal)(
          §set_math_id["neq", "neq"]
          §p(Two objects are §rdef(unequal), written as §$(x §$neq y), if they are not §r(equal).)
        ), we write §$(x §$neq y).
      )§p(
        We can now disprove §cref(tour_order2) by proving its §r(negation):
      )

      §statement["tour_not_order2"](
        §p(It is not the case that there exists a natural number §$(m) such that for all natural numbers §$(n) we have §$(n §$eq m).)
      )(
        §p(
          We can prove the statement by showing that for all natural numbers §$(m) it is not the case that for all natural numbers §$(n) we have §$(n §$eq m). This we can prove by showing that for all natural numbers §$(m) there exists a natural number §$(n) such that §$(n §$neq m).
        )§p(
          Let §$(m) be a natural number. Define §$(n §$defeq m + 1). Then §$(n §$neq m), because §$(m + 1 §$neq m).
        )
      )

      §p(
        Disproving statements by proving their §r(negation) makes sense only if we assume that every statement must either be true or false. This assumption is known as the §definex(principle of bivalence)(
          §p(The §rdef(principle of bivalence) states that every statement is either true or false.)
        ), and while it might feel self-evident, it is possible to find self-consistent frameworks for §r(deductive reasoning) that reject it. To keep things compact, this book consistently sticks to the prevalent school of §verbatim(classical mathematics) that accepts the §r(principle of bivalence).
      )

      §p(
        The proof of §cref(tour_not_order2) is representative for how we usually prove §r(negation)(negated) statements: First, we convert the statement into an equivalent one in which the only §r(negation)(negated) sub-statements are statements of §r(equal)(equality), and then, we prove that new statement as usual, without having to worry about §rs(negation) anymore.
      )§p(
        Because this conversion is completely mechanical, it is often left implicit in written proofs. Incorrect manipulation of §rs(negation) is a common source of errors for new learners however, so it is a good habit to carefully and explicitly think through the process of threading a §r(negation) through a statement, whenever you encounter it.
      )

      §exercise["exercise_tour_not"](
        Disprove that for all natural numbers §$(n) there exists a natural number number §$(m) such that §$(n) is not §r(less than or equal to) §$(m). Explicitly state the different stages of moving the §r(negation) through the statement to reach a statement you can prove.
      )

    )



  )
)
