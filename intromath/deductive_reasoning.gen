§template(

)(
  §hsection["chapter_deductive_reasoning"](Deductive Reasoning)(
    §p(
      Have you ever wondered why the integers §$(§()(§$ldots§ , -2, -1, 0, 1, 2, §$ldots)(§)) do not include a negative zero? When the integers are having a party, the non-zero integers are each dancing with their partner of the opposite sign, while poor zero stands alone in a corner, hoping against hope that someday a negative zero might show up. Well, today is the day we use the power of mathematics to forever crush those dreams.
    )§p(
      A distinctive property of the number §highlightlow1(zero) is that adding or subtracting it to or from other numbers has no effect: for any integer §$(z) we always know that §$(§$highlightlowr1(0) + z = z, z + §$highlightlowr1(0) = z)(,) and §$(z - §$highlightlowr1(0) = z)(.) Because §$(z - §$highlightlowr1(0) = z)(,) and adding a negative number is the same as subtracting the corresponding positive number, we also know that adding §highlightlow3(negative zero) to any number would have no effect: §$(§$highlightlowr3(-0) + z = z) and §$(z + §$highlightlowr3(-0) = z) for any integer §$(z)(.)
    )§p(
      If adding §highlightlow3(negative zero) to any integer has no effect, then, in particular, we can add it to §highlightlow1(zero) without effect: §$(§$highlightlowr1(0) = §$highlightlowr1(0) + §$highlightlow3(-0))(.) We also know that §$(§$highlightlowr1(0) + §$highlightlowr3(-0) = §$highlightlow3(-0)), because adding any number to §highlightlow1(zero) results in that number again. But if §$(§$highlightlowr1(0) = §$highlightlowr1(0) + §$highlightlow3(-0)) and §$(§$highlightlowr1(0) + §$highlightlowr3(-0) = §$highlightlow3(-0))(,) then also §$(§$highlightlowr1(0) = §$highlightlow3(-0))(.) So §$(§$highlightlow3(-0)) is actually the same number as §$(§$highlightlow1(0))(,) there can be no distinct zeros of different signs.
    )§p(
      This line of reasoning demonstrates the technique that lies at the very heart of mathematics: deductive reasoning.
    )

    §hsection["section_deductive_reasoning"](Gathering Knowledge)(
      §p(
        §definex["deductive_reasoning"](deductive reasoning)(deductive reasonings)(Deductive reasoning)(§Rdef(deductive reasoning) is the process of concluding facts from assumptions.) is the process of concluding facts from assumptions. If we assume that squirrels are always hungry, and that Alex is a squirrel, we can conclude that Alex is always hungry. A framework for §r(deductive reasoning) must provide clear rules on which deduction steps are valid. If, for example, we knew that Vic was always hungry, we should §em(not) be able to conclude that Vic is a squirrel; Vic could be a badger for all we know.
      )§p(
        Contrast this with §definex["inductive_reasoning"](inductive reasoning)(§Rdef(inductive reasoning) is the process of hypothesizing causes from observed facts.), the process of hypothesizing causes from observed facts. From observing that the sun rises and sets every day, you might form the potential explanation that the sun orbits the §side(earth)(According to current scientific consensus, it does not.). Later observations might invalidate a hypothesis, but a hypothesis can never be proven beyond doubt.
      )§p(
        Even though §r(inductive reasoning) can lead to false conclusions, it has its firm place in humanity's quest for knowledge. Physics or chemistry, for example, would make little sense if they were not grounded in observations of the world around us. They can strive to find increasingly accurate models of the world, but there could always come a new observation that contradicts the existing models.
      )§p(
        Unlike the natural sciences, mathematics relies on §r(deductive reasoning) alone. Rigorous adherence to the principle that every claim has to follow from either assumptions or previously proven claims may not be a normal mode of operation for your brain, but learning to operate that way comes with a number of benefits:
      )§ul(
        §li(
          Proven knowledge is permanent. It does not degrade, it does not go out of style, it will not be falsified by a future observation. This has enabled mathematicians to build up knowledge over centuries.
        )
        §li(
          Proven knowledge is verifiable. It does not matter who wrote a proof, whether you trust them or not. If every single step follows the deduction rules, then the resulting information is true.
        )
        §li(
          Proven knowledge is inspectable. If you do not understand why something is true, the proof breaks it down for you into small, almost obviously correct §side(steps)(More often than not, the person who wrote that initially incomprehensible proof is yourself from the past. But if the proof is well written, you will always be able to untangle it.).
        )
        §li(
          Proven knowledge is composable. Once a fact has been proven, it can be reused in further proofs. Furthermore, the details of how it was proven do not affect that reuse in any way.
        )
      )§p(
        Once mastered, §r(deductive reasoning) enables you to think thoughts you would not have been able to think otherwise, because you would have been overwhelmed by the sheer amount of details and the accumulation of tiny errors.
      )§p(
        A key property of §r(deductive reasoning) is that the mere §em(form) of a statement already implies how to prove it. Suppose we want to prove that there exists at least one hungry badger, how do we go about it? By presenting an actual hungry badger. How do you prove that there exists at least one flying squirrel? By presenting an actual flying squirrel. If however we wanted to prove that §em(all) squirrels can fly, presenting an individual flying one would not help at all.
      )§p(
        Consequently, the fewer different forms of statements there are, the less complicated the system of §r(deductive reasoning) becomes. In the next section, we examine a small number of constructs for forming statements, chosen so that any statement of interest can be expressed using these constructs. The accompanying examples may feel trivial or even boring in their simplicity. That is an incredibly important and desired aspect of the system. Proving facts should not in itself be difficult; all complexity should come from the subject matter at hand, not the proof mechanism itself. Humanity has expended a great deal of collective §side(brainpower)(The wikipedia page on the §link(history of logic)(https://en.wikipedia.org/wiki/History_of_logic) gives a nice overview on more than two millennia of activity.) so that the contents of the following section would become as simple as possible.
      )

    )

    §hsection["section_whirlwind_tour"](A Whirlwind Tour of Tiny Proofs)(
      §side*()(Fair warning: this section provides a thorough, text-heavy presentation of vital but not terribly exciting information. Not everyone enjoys learning from that kind of material. If you struggle with such passages, you might want to directly skip to the §cref(chapter_sets)(next chapter), which has fluffy, interactive visualizations and other niceties. Whenever you encounter an unknown term there, you can click on it to jump back to its definition.)
      §p(
        In order to formulate statements, we first need objects that the statements can talk about. For the coming examples, we will use the natural numbers §$(§()(0, 1, 2, §$ldots)(§).) To demonstrate that this mode of reasoning can be applied to anything really, we will also talk about a population of friendly (and presumably hungry) squirrels: §$(§$value(Alex))(,) §$(§$value(Blake))(,) and §$(§$value(Charlie))(.)
      )§p(
        A squirrel by itself is not a statement; §$(§$value(Alex)) is neither true nor false, but merely an adorable object of interest. The same applies to the number §$(17)(,) although arguably less adorable. We can bridge into the world of statements by comparing objects for equality:
      )§definition["eq"](Equality)(
        §set_math_id["eq", "eq"]
        §p(
          Two objects are considered §define["equal"](equal) if they are identical: everything is equal to itself, but not equal to anything else. Claiming that two objects are §r(equal) is a statement. We write §$(§lquote)(x §$eq y)(§rquote) to compactly express that the object §$(x) is §r(equal) to the object §$(y)(.)
        )
      )

      §p(
        This already establishes enough concepts to look at a first statement and how to prove it.
      )

      §proven_fact(
        §statement["tour_equality"](
          §p(§i(Claim:) §$(17 §$eq 17)(.))
        )
        §proof["tour_equality"](
          §p(The claim holds by the §r(equal)(definition of equality).)
        )
      )

      §p(
        Though rather unexciting, this is our first real proof. Introducing the concept of §r(equal)(equality) would be rather pointless if we could not immediately determine whether any two objects are §r(equal) or not.
      )§p(
        We can make things slightly more interesting by adding §definex["tour_def_term"](term)(terms)(terms)(
          A §rdef(term) denotes a way of obtaining objects of interest from other objects or other §rs(term).
        ) such as §$(1 + 2) to our language of statements. A §r(term) always denotes a way of obtaining objects of interest from other objects or other §rs(term). In our examples, §$(§lquote)(+)(§rquote) denotes addition of two §side(numbers)(
          We refrain from giving a precise definition of §$(§lquote)(+)(§rquote) in this chapter, simply taking the results of concrete computations as granted. Occasionally, the example proofs make use of simple properties, for example, the fact that adding zero to a number yields that number again. Such properties would usually have to be proven from the definition of §$(§lquote)(+)(§rquote§ ,) we will simply assume them to be true in order to focus on the mechanics of §r(deductive reasoning) instead.§br
          §cref(chapter_induction) contains a precise definition of natural numbers and addition, as well as proofs for the properties we assume to hold in this chapter.
        ).
      )

      §proven_fact(
        §statement["tour_terms"](
          §p(§i(Claim:) §$(5 + 12 §$eq 17)(.))
        )
        §proof["tour_terms"](
          §p(§$(5 + 12) is §$(17)(,) and §$(17 §$eq 17) by the §r(equal)(definition of equality).)
        )
      )

      §p(
        Introducing §rs(term) still does not add any real depth however: after evaluating the §rs(term), their §r(equal)(equality) also either does or does not hold by definition. To formulate and prove more meaningful statements, we need the ability to define statements whose truth depends on the truth of other statements.
      )

      §hsection["quantifiers"](Quantifiers)(
        §p(
          The first such statements we examine are those of §definex["existential_quantification"](existential quantification)(
            §p(
              A statement of §rdef(existential quantification) asserts that there exists at least one object satisfying a certain property: §lquote§ There exists a natural number §$(n) such that §$(n = 17)(§rquote§ .)
            )§p(
              You prove a statement of §r(existential quantification) by presenting a §r(witness), that is, an object that satisfies the required property: §lquote§ Define §$(n §$defeq 17)(,) then §$(n §$eq 17)(§rquote§ .)
            )
          ), which is just fancy terminology for stating that at least one object satisfying a certain property exists:
        )

        §proven_fact(
          §statement["tour_existential_quantification"](
            §p(There exists a squirrel §$(s) such that §$(s §$eq §$value(Alex))(.))
          )
          §proof["tour_existential_quantification"](
            §p(Define §$(s §$defeq §$value(Alex))(,) then §$(s §$eq §$value(Alex))(.))
          )
        )

        §p(
          You prove §r(existential quantification)(statements of this form) by presenting a §definex["witness"](witness)(witnesses)(
            §p(A §rdef(witness) for a statement of §r(existential quantification) is an object for which the quantified claim holds.)
          ), that is, an object that satisfies the required property. Note how two symbols that looks similar but have very different meaning appear in the proof: §$(§lquote)(§$eq)(§rquote) signifies a statement that is true if both sides of the symbol denote the same object, whereas §definex["defeq"](defeq)()()(
            §p(The §$(§lquote)(§$defeq)(§rquote) symbol makes the name on its left denote the object on its right: §lquote§ Define §$(x §$defeq 42), then §$(x §$eq 42)(§rquote§ .))
          )§set_math_id["defeq", "defeq"]§set_math_id["eqdef", "defeq"]§$(§lquote)(§$defeq)(§rquote) makes the name on the left side denote the object on the right side.
        )§p(
          As §r(existential quantification) allows us to construct statements that contain other statements, we can formulate statements with multiple, nested levels of quantification:
        )

        §proven_fact(
          §statement["tour_existential_quantification_nested"](
            §p(There exists a squirrel §$(s) such that there exists a squirrel §$(t) such that §$(s §$eq t)(.))
          )
          §proof["tour_existential_quantification_nested"](
            §p(Define §$(s §$defeq §$value(Charlie)) and §$(t §$defeq §$value(Charlie))(,) then §$(s §$eq t)(.))
          )
        )

        §exercise["tour_existential_quantification_atleast"](
          §p(
            When mathematicians say §verbatim(there)(exists an)(object) they mean §verbatim(there)(exists at least one object, and there may or may not be)(more). Why is that, and why is it not necessary to say so explicitly?
          )
          §solution["tour_existential_quantification_atleast"](
            §p(
              Presenting a single §r(witness) proves the statement. Whether there are multiple other §rs(witness) does not change that.
            )
          )
        )

        §p(
          Besides §r(existential quantification) for asserting that a statement holds for at least one object, there is §definex["universal_quantification"](universal quantification)(
            §p(
              A statement of §rdef(universal quantification) asserts that all objects satisfy a certain property: §lquote(For) each natural number §$(n) holds that §$(n §$eq n)(§rquote§ .)
            )§p(
              You prove a statement of §r(universal quantification) by showing that an arbitrarily chosen object satisfies the required property: §lquote(Let) §$(n) be a natural number. Then §$(n §$eq n)(§rquote§ .)
            )
          ) for asserting that a statement holds for all objects:
        )

        §proven_fact(
          §statement["tour_universal_quantification"](
            §p(For each natural number §$(n) holds that §$(n §$eq n)(.))
          )
          §proof["tour_universal_quantification"](
            §p(Let §$(n) be a natural number. Then §$(n §$eq n) by the §r(equal)(definition of equality).)
          )
        )

        §p(
          Because there are infinitely many natural numbers, we cannot prove a statement about every single number by going through all of them; we need our proofs to be of finite size. The only way to prove statements of §r(universal quantification) is by showing that the property in question holds for an arbitrarily chosen object, one about which we know nothing except that it is the kind of object that the statement speaks of. Throughout the book, we always use the phrase §verbatim(let)(§$(x) be a)(§i(something)) to express when this is happening. Proving statements by working with arbitrarily chosen, featureless objects usually takes some getting used to, but it is the only way of proving statements about infinitely many objects.
        )§p(
          The phrase §verbatim(let)(§$(x) be a)(§i(something)) is also sometimes used as a different way of §em(formulating) statements of §r(universal quantification), most often to specify in advance which kinds of objects a statement will talk about. The following example expresses exactly the same fact as §cref(tour_universal_quantification) (and thus admits an identical proof), merely formulated differently:
        )

        §proven_fact(
          §statement["tour_assumptions"](
            §p(
              Let §$(n) be a natural number. Then §$(n §$eq n)(.)
            )
          )
          §proof["tour_assumptions"](
            §p(Let §$(n) be a natural number. Then §$(n §$eq n) by the §r(equal)(definition of equality).)
          )
        )

      )

      §hsection["definitions"](Definitions)(
        §p(
          §R(existential quantification) and §r(universal quantification) enable us to define a more interesting relation between numbers than §r(equal)(equality):
        )

        §definition["leq"](
          §set_math_id["leq", "leq"]
          §p(
            Let §$(n) and §$(m) be natural numbers. We say that §$(n) is §define(less than or equal to) §$(m)(,) written as §$(n §$define_notation(§$leq) m)(,) if there exists a natural number §$(k) such that §$(n + k §$eq m)(.)
          )
        )

        §p(
          With this concept defined, we can formulate statements about numbers being §r(less than or equal to) other numbers:
        )

        §proven_fact(
          §statement["tour_leq"](
            §p(
              §i(Claim:) §$(12 §$leq 17)(.)
            )
          )
          §proof["tour_leq"](
            §p(
              Define §$(k §$defeq 5)(.) Then §$$align*(
                  12 + k &§$eq 12 + 5 §$tag(Definition $k$)
                )(
                  &§$eq 17, §$tag(Definition $+$)
                ) and §side(thus)(
                The intent behind chaining §r(equal)(equal signs) as in §span(nowrap)(§$(§lquote)(12 + k §$eq 12 + 5 §$eq 17)(§rquote)) is to express that the §rs(term) on the two sides of each §$(§lquote)(§$eq)(§rquote) are §r(equal) to each other, and that consequently the first §r(term) is §r(equal) to the last one.§br
                This interpretation is different from that of each §$(§lquote)(§$eq)(§rquote) expressing a new statement; technically we must write something along the lines of §$(§lquote)(12 + k §$eq 12 + 5)(,) §$(12 + 5 §$eq 17)(,) and thus §$(12 + k §$eq 17)(§rquote) instead.§br
                The notational convention of chaining §r(equal)(equal signs) is so useful and commonplace however that we make use of it as well.
              ) §$(12 §$leq 17)(.)
            )
          )
        )

        §drop(
          §theorem*["tour_neutral_addition"](Neutral Element of Addition)(
            §p(
              Let §$(n) be a natural number. Then §$(n + 0 §$eq n)(,) and §$(0 + n §$eq n)(.)
            )
          )
        )

        §proven_fact(
          §statement["tour_leq2"](
            §p(
              Let §$(n) be a natural number. Then §$(n §$leq n)(.)
            )
          )
          §proof["tour_leq2"](
            §p(
              Let §$(n) be a natural number. Define §$(k §$defeq 0)(.) Then §$$align*(
                n + k &§$eq n + 0 §$tag(Definition $k$)
              )(
                &§$eq n, §$tag(§cref(tour_neutral_addition)(Neutral Element) $+$)
              ) and thus §$(n §$leq n)(.)
            )
          )
        )

        §p(
          As you can see, a definition is nothing but a shorthand; proofs proceed by unfolding the definition and then continuing as if the body of the definition had been used rather than its shorter name. Naming recurring concepts is vital to achieving concise yet precise communication, and it can also help in clarifying thought processes. This can lead to short sentences carrying large amounts of information, but this information can always be recovered by repeatedly unfolding definitions.
        )§p(
          This book tries to make the unfolding of definitions as easy as possible: you can hover over any defined terminology (for example, §lquote§ §r(less than or equal to)§rquote§ ) or symbol (for example, §verbatim(§$(§$leq))) and the definition will open in a tooltip. The terminology or symbol is also a hyperlink to its definition.
        )

        §proven_fact(
          §statement["exercise_tour_leq"](
            §p(For each natural number §$(n) holds that §$(0 §$leq n)(.)§side*()(In this book, statements with hidden proofs are opportunities for you to practice your skills. Try to prove the statement yourself, and then compare. For more complicated statements, it is perfectly normal for your proof and the suggested solution to differ; there are usually many different ways of proving the same statement.))
          )
          §proof["exercise_tour_leq"](
            §proof_as_exercise["exercise_tour_leq"](
              Let §$(n) be a natural number. Define §$(k §$defeq n)(.) Then §$$align*(
                0 + k &§$eq 0 + n §$tag(Definition $k$)
              )(
                &§$eq n, §$tag(§cref(tour_neutral_addition)(Neutral Element) $+$)
              ) and thus §$(0 §$leq n)(.)
            )
          )
        )

        §p(
          Originally, §r(equal)(equality) was our only way of moving from objects of interest to statements of truth: §$(§lquote)(17)(§rquote) is not a statement (it is neither true nor false), but §$(§lquote)(17 §$eq 18)(§rquote) is (albeit a false one). The newly defined concept of numbers being §r(less than or equal to) each other achieves the same shift of conceptual level, it combines a number of §rs(term) into a statement. We call such concepts §definex["predicate"](predicate)(predicates)(predicates)(
            §p(
              A §rdef(predicate) combines a number of §rs(term) into a statement.
            )§p(
              The prototypical §r(predicate) is §r(equal)(equality): §$(§lquote)(17)(§rquote) is not a statement (it is neither true nor false), but §$(§lquote)(17 §$eq 18)(§rquote) is.
            )
          ).
        )§p(
          Aside from defining new §rs(predicate), we can also define new §rs(term), that is, new ways of compactly describing objects of interest based on other objects:
        )

        §definition["twice"](
          §set_math_id["twice", "twice"]
          §p(
            Let §$(n) be a natural number. We denote by §$(§$define_notation(§$twice(§$text_color(n)))) the number §$(n + n)(.)
          )
        )
        §proven_fact(
          §statement["tour_twice"](
            §p(
              There exists a natural number §$(n) such that §$(§$twice(n) §$eq n)(.)
            )
          )
          §proof["tour_twice"](
            §p(
              Define §$(n §$defeq 0)(,) then §$$align*(
                §$twice(n) &§$eq n + n §$tag(§cref(twice)(Definition) $§$twice(n)$)
              )(
                &§$eq 0 + 0 §$tag(Definition $n$)
              )(
                &§$eq 0 §$tag(§cref(tour_neutral_addition)(Neutral Element) $+$)
              )(
                &§$eq n. §$tag(Definition $n$)
              )
            )
          )
        )

      )

      §hsection["utilizing_quantification"](Using Quantifications)(
        §p(
          Once a statement of §r(universal quantification) has been proven, the acquired knowledge can be used in other proofs:
        )

        §proven_fact(
          §statement["use_universal"](
            §p(§i(Claim:) §$(5 §$leq 5)(.))
          )
          §proof["use_universal"](
            §p(§$(5) is a natural number. Thus, by §cref(tour_leq2), §$(5 §$leq 5)(.))
          )
        )

        §p(
          It would not have been difficult to prove §cref(use_universal) directly, but utilizing §cref(tour_leq2) saved us the trouble of finding a suitable §r(witness) §$(k) to add to §$(5)(.) In fact, our proof works even if we have no idea how §verbatim(§$(§$leq)) is defined. This hints at one of the key strengths of §r(deductive reasoning): we can reason in terms of high-level concepts (such as §verbatim(§$(§$leq))) while still getting the guarantee that everything works because it can ultimately be broken down to simple and correct building blocks (§r(equal)(equality) and §r(existential quantification) in this case).
        )

        §p(
          Using a statement of §r(existential quantification) is less straightforward than using a statement of §r(universal quantification). You know that some §r(witness) satisfying a certain property exists, but you do not know anything else about that §r(witness). Thus, you cannot utilize any further properties of the §r(witness) in your proof.
        )

        §proven_fact(
          §statement["use_existential"](
            §p(§i(Claim:) §$(12 §$leq 18)(.))
          )
          §proof["use_existential"](
            §p(
              By §cref(tour_leq) we know that §$(12 §$leq 17)(.) From the definition of §verbatim(§$(§$leq)) we obtain §$(k) such §side(that)(This is precisely where we use the statement of §r(existential quantification). §em(You) might know that the §r(witness) is §$(5)(,) but the fact that §$(12 §$leq 17) does not include that information — it only states that §em(some) §r(witness) must exist.) §$(12 + k §$eq 17)(.)
            )§p(
              If §$(12 + k §$eq 17)(,) then also §$(§$p(12 + k) + 1 §$eq 17 + 1)(,) then also §$(§$p(12 + k) + 1 §$eq 18)(,) and then also §$(12 + §$p(k + 1) §$eq 18)(.)
            )§p(
              §$(k + 1) is a natural number, so we have §side(found)(Interestingly enough, the proof gives us no idea which number it actually is. Nevertheless, we know for sure that there is a §r(witness) for §$(12 §$leq 18)(.)) a number that we can add to §$(12) to obtain §$(18)(.) Or in other words, we have proven that §$(12 §$leq 18)(.)
            )
          )
        )

        §p(
          Compared to directly choosing a suitable number to add to §$(12)(,) this proof is of course needlessly complicated. But it demonstrates how to work with this number §$(k) that we know very little about.
        )

        §p(
          You can argue that knowing a statement of §r(universal quantification) is more useful than knowing a statement of §r(existential quantification), because it can be more readily used in further proofs. This is offset by the fact that statements of §r(existential quantification) are much easier to prove — providing a specific §r(witness) is easier than working with abstract values which can represent any number of concrete values.
        )§p(
          Interestingly enough, you can also take on a completely opposite view. What is interesting about properties that hold for every single object there is? §R(existential quantification) conveys the actually useful facts, it talks about the hidden gems among the masses of uninteresting objects. Unfortunately, these statements are much more difficult to prove — you need a clever idea for finding an object with the desired properties, rather than being handed an uncomplicated, distraction-free, abstract value to work with.
        )

      )

      §hsection["names"](Names)(
        §p(
          At this point, we should briefly discuss §definex["name"](name)(names)(names)(
            §p(
              A §rdef(name) is a shorthand for a §r(term) or object. Every name must be bound to a §r(term) or object through one of the following constructs:
            )§ul(
              §li(
                Formulating §rs(universal quantification): §verbatim(For)(each squirrel §$(s) holds)(that…).
              )§li(
                Proving §rs(universal quantification): §verbatim(Let)(§$(s) be a squirrel,)(then…).
              )§li(
                Formulating §rs(existential quantification): §verbatim(There)(exists a squirrel §$(s) such)(that…).
              )§li(
                Using §rs(existential quantification): §verbatim(Obtain)(a squirrel §$(s) such)(that…).
              )§li(
                Explicit §r(defeq)(naming): §lquote(Define) §$(s §$defeq §$ldots)(§rquote§ .)
              )
            )
          ), which we have started using in §rs(term) such as §$(§lquote)(n + k §$eq 17)(§rquote) without prior discussion. §Rs(name) can stand in for objects or §rs(term), but they never drop out of nowhere. Every §r(name) has to be introduced before it can appear in a proof: if we have no idea what §$(x) is, how are we to determine whether the statement §$(§lquote)(x §$eq 6)(§rquote) is true or false?
        )§p(
          There is only a limited number of ways in which §rs(name) can be introduced, and we have already seen all of them:
        )§ul(
          §li(
            Formulating §rs(universal quantification): §verbatim(For)(each squirrel §$(s) holds)(that…).
          )§li(
            Proving §rs(universal quantification): §verbatim(Let)(§$(s) be a squirrel,)(then…).
          )§li(
            Formulating §rs(existential quantification): §verbatim(There)(exists a squirrel §$(s) such)(that…).
          )§li(
            Using §rs(existential quantification): §verbatim(Obtain)(a squirrel §$(s) such)(that…).
          )§li(
            Explicit §r(defeq)(naming): §lquote(Define) §$(s §$defeq §$ldots)(§rquote§ .)
          )
        )
        §p(
          Each time you see a §r(name), and each time you use one yourself, it must have been introduced by exactly one of these §side*(constructs)(
            There is no requirement for §rs(name) to consist of a single letter. Especially when writing long, complicated proofs, it can be helpful to use more descriptive §rs(name).
          ). The precise wording for the construct can of course vary, as long as it is clear which of the five constructs is meant. But sticking to exactly one formulation per construct will make your proofs easier to follow.
        )§p(
          §R(name) introductions usually bind the §r(name) until the end of the current text component, for example, until the end of the current statement, definition, (sub-)exercise, and so on. That is why the statements in this chapter quantify §$(n) again and again.
        )

      )

      §hsection["quantifier_order"](Quantifier Order)(
        §p(
          Does it matter in which order the quantifications in a statement occur? It does not for nested §rs(existential quantification) such as those of §cref(tour_existential_quantification_nested): It makes no difference in which order we define the §rs(witness), so the same proofs still work if the order of the quantifications in the statement is swapped. The same is the case for nested statements of §r(universal quantification), the order in which we obtain the featureless values for which to prove the desired properties does not matter for the proof to be correct.
        )§p(
          These observations are examples of §definex["meta_statement"](meta statement)(meta statements)(meta statements)(
            §p(
              A §rdef(meta statement) is a statement about statements.
            )
          ), statements about §side(statements)(As §rs(meta statement) are indeed statements, they can be proven. We refrain from doing so in this book, because introducing the necessary formalism goes beyond a mere introduction to mathematics. The field that studies §rs(meta statement) is that of §link(mathematical logic)(https://en.wikipedia.org/wiki/Mathematical_logic).). To be a bit more precise in formulating §rs(meta statement), we say that two statements §definex["equivalent_statements"](mean the same)(
            §p(
              Two statements §rdef(mean the same) if, whenever we can prove one of them, we can also prove the other.
            )
          ) if, whenever we can prove one of them, we can also prove the other. Restating our observations about quantifier order: If we swap two successive §rs(existential quantification) (or two successive §rs(universal quantification)), the old and new statement §r(mean the same).
        )

        §p(
          When §em(interleaving) §r(existential quantification) and §r(universal quantification) however, the quantifier order can make a difference, as exemplified by the following statement:
        )

        §proven_fact(
          §statement["tour_order"](
            §p(For each natural number §$(n) there exists a natural number §$(m) such that §$(n §$eq m)(.))
          )
          §proof["tour_order"](
            §p(
              Let §$(n) be a natural number. Define §$(m §$defeq n)(.) Then §$(n §$eq m)(.)
            )
          )
        )

        §p(
          §cref(tour_order)(This statement) is true, but what happens if we swap the order of the quantifiers?
        )

        §falsehood["tour_order2"](
          §p(There exists a natural number §$(m) such that for each natural number §$(n) holds §$(n §$eq m)(.))
        )

        §p(
          §cref(tour_order2) is clearly different from §cref(tour_order), there certainly is no number that is §r(equal) to every number. But how do we disprove a statement? For that, we need to examine the concept of negated statements.
        )
      )

      §hsection["negations"](Negations)(
        §p(
          The §definex["negation"](negation)(
            §p(
              A §rdef(negation) asserts that another statement does not hold.
            )§p(
              You prove a §r(negation)(negated) statement depending on the kind of statement that is being §r(negation)(negated).
            )
          ) of a statement is a new statement that is true if the old statement is false, and vice versa. Or in other words, a §r(negation) asserts that another statement does not hold. How do we prove a §r(negation)(negated) statement? That depends on the kind of statement that is being §r(negation)(negated). The easiest case is that of an §r(equal)(equality), whose truth can be derived directly by definition:
        )

        §proven_fact(
          §statement["tour_negation_eq"](
            §p(It does not hold that §$(5 §$eq 6)(.))
          )
          §proof["tour_negation_eq"](
            §p(§$(5 §$eq 6) does not hold by §r(equal)(the definition of equality), so the §r(negation) of §$(5 §$eq 6) does hold.)
          )
        )

        §p(
          Another easy case is that of a §r(negation)(negated) §r(negation) (a §definex["double_negation"](double negation)(A §rdef(double negation) is the §r(negation) of a §r(negation).)), which is simply canceled out.
        )

        §proven_fact(
          §statement["tour_negation_negation"](
            §p(It does not hold that it does not hold that §$(5 §$eq 5)(.))
          )
          §proof["tour_negation_negation"](
            §p(
              The statement that remains after eliminating the §r(double negation) is §$(5 §$eq 5)(,) which holds by §r(equal)(the definition of equality).
            )
          )
        )

        §p(
          More interesting are §rs(negation) of quantifications. If a statement does not hold for all objects, then there has to exist a counterexample. In other words, we can prove the §r(negation) of a statement of §r(universal quantification) by changing it to §r(existential quantification) and moving the §r(negation) past the quantifier:
        )

        §proven_fact(
          §statement["tour_negation_universal"](
            §p(It does not hold for each squirrel §$(s) that §$(s §$eq §$value(Alex))(.))
          )
          §proof["tour_negation_universal"](
            §p(
              We can prove the statement by showing that there exists a squirrel §$(s) such that it does not hold that §$(s §$eq §$value(Alex))(.) Define §$(s §$defeq §$value(Blake))(.) Then it does not hold that §$(s §$eq §$value(Alex))(.)
            )
          )
        )

        §p(
          Conversely, if no object satisfying a property exists, then all objects do not satisfy that property. That is, we can prove the §r(negation) of a statement of §r(existential quantification) by changing it to §r(universal quantification) and moving the §r(negation) past the quantifier.
        )

        §proven_fact(
          §statement["tour_negation_existential"](
            §p(It does not hold that there exists a squirrel §$(s) such that it does not hold that §$(s §$eq s)(.))
          )
          §proof["tour_negation_existential"](
            §p(
              We can prove the statement by showing that for each squirrel §$(s) it does not hold that it does not hold that §$(s §$eq s)(.) Let §$(s) be a squirrel. Then §$(s §$eq s)(,) which is exactly what remains to be proven after the §r(double negation) has been eliminated.
            )
          )
        )

        §p(
          §Rs(negation) are usually formulated less verbosely, for example §verbatim(it)(does not hold that there exist §$(x) such)(that…) would normally be written along the lines of §verbatim(there)(exists no §$(x) such)(that…). The negation of statements of §r(equal)(equality) even has its own symbol: if §$(x) and §$(y) are §definex["neq"](unequal)(
            §set_math_id["neq", "neq"]
            §p(Two objects are §rdef(unequal), written as §$(x §$neq y)(,) if they are not §r(equal).)
          ), we write §$(x §$neq y)(.)
        )§p(
          We can now disprove §cref(tour_order2) by proving its §r(negation):
        )

        §proven_fact(
          §statement["tour_not_order2"](
            §p(There exists no natural number §$(m) such that for each natural number §$(n) holds §$(n §$eq m)(.))
          )
          §proof["tour_not_order2"](
            §p(
              We can prove the statement by showing that for each natural number §$(m) it is not the case that for each natural number §$(n) holds §$(n §$eq m)(.) This we can prove by showing that for each natural number §$(m) there exists a natural number §$(n) such that §$(n §$neq m)(.)
            )§p(
              Let §$(m) be a natural number. Define §$(n §$defeq m + 1)(.) Then §$(n §$neq m)(,) because §$(m + 1 §$neq m)(.)
            )
          )
        )

        §p(
          Disproving statements by proving their §r(negation) makes sense only if we assume that every statement must either be true or false. This assumption is known as the §definex["bivalence"](principle of bivalence)(
            §p(The §rdef(principle of bivalence) states that every statement is either true or false.)
          ), and while it might feel self-evident, it is possible to find self-consistent frameworks for §r(deductive reasoning) that reject it. To keep things compact, this book consistently sticks to the prevalent school of §em(classical mathematics) that accepts the §r(principle of bivalence)§side()(The schools of mathematics that reject the §r(principle of bivalence) are collectively referred to as §link(§em(constructive mathematics))(https://en.wikipedia.org/wiki/Constructivism_(philosophy_of_mathematics)).).
        )

        §p(
          The proof of §cref(tour_not_order2) is representative for how we usually prove complex §r(negation)(negated) statements: First, we convert the statement into an equivalent one in which the only §r(negation)(negated) substatements are §rs(predicate). Then, we prove that new statement as usual, without having to worry about §rs(negation) anymore.
        )§p(
          Because this conversion is completely mechanical, it is often left implicit in written proofs. Incorrect manipulation of §rs(negation) is a common source of errors for new learners however, so it is a good habit to always think carefully and explicitly through the process of threading a §r(negation) through a statement.
        )

        §exercise["exercise_tour_not"](
          §p(
            Disprove that for each natural number §$(n) there exists a natural number §$(m) such that §$(n) is not §r(less than or equal to) §$(m)(.) Explicitly state the different stages of moving the §r(negation) through the statement to reach a statement you can prove.
          )
          §solution["exercise_tour_not"](
            §p(
              To disprove the statement, we first formulate its negation: it does not hold for each natural number §$(n) that there exists a natural number §$(m) such that §$(n) is not §r(less than or equal to) §$(m)(.)
            )§p(
              Next, we move the §r(negation) through the §r(universal quantification): there exists a natural number §$(n) such that there exists no natural number §$(m) such that §$(n) is not §r(less than or equal to) §$(m)(.)
            )§p(
              We continue propagating the §r(negation): there exists a natural number §$(n) such that for each natural number §$(m) it does not hold that §$(n) is not §r(less than or equal to) §$(m)(.)
            )§p(
              We can now eliminate the §r(double negation): there exists a natural number §$(n) such that for each natural number §$(m) holds that §$(n) is §r(less than or equal to) §$(m)(.)
            )§p(
              This statement we can prove: Define §$(n §$defeq 0)(,) then §$(n §$leq m) by §cref(exercise_tour_leq).
            )
          )
        )§exercise["wrong_negation_existential"](
          §p(
            A common mistake when §r(negation)(negating) statements of §r(existential quantification) is to propagate the §r(negation) without swapping to §r(universal quantification).
          )§p(
            Give a §r(predicate) §verbatim(§meta1) such that §verbatim(there)(exists no squirrel §$(s) such that)(§meta1) and §verbatim(there)(exists a squirrel §$(s) such that not)(§meta1) do not §r(mean the same).
          )
          §solution["wrong_negation_existential"](
            §p(
              Consider the §r(predicate) of being §r(equal) to §$(§$value(Alex))(.) The statement that there exists no squirrel §$(s) such that §$(s §$eq §$value(Alex)) is false, because if we define §$(s §$defeq §$value(Alex))(,) then §$(s §$eq §$value(Alex)) does hold.
            )§p(
              If we propagate the §r(negation) without swapping to §r(universal quantification) however, the statement becomes true: there exists a squirrel §$(s) such that §$(s §$neq §$value(Alex))(,) for example, §$(s §$defeq §$value(Blake))(.)
            )
          )
        )§exercise["wrong_negation_universal"](
          §p(
            A common mistake when §r(negation)(negating) statements of §r(universal quantification) is to propagate the §r(negation) without swapping to §r(existential quantification).
          )§p(
            Give a §r(predicate) §verbatim(§meta1) such that §verbatim(it)(does not hold that for each squirrel §$(s) holds)(§meta1) and §verbatim(for)(each squirrel §$(s) does not hold)(§meta1) do not §r(mean the same).
          )
          §solution["wrong_negation_universal"](
            §p(
              Consider the §r(predicate) of being §r(equal) to §$(§$value(Alex))(.) It is true that we do not have for every squirrel §$(s) that §$(s §$eq §$value(Alex)), because if we define §$(s §$defeq §$value(Blake))(,) then §$(s §$neq §$value(Alex))(.)
            )§p(
              If we propagate the §r(negation) without swapping to §r(existential quantification) however, the statement becomes false: every squirrel §$(s) being not §r(equal) to §$(§$value(Alex)) is refuted by choosing §$(s §$defeq §$value(Alex))(.)
            )
          )
        )

      )

      §hsection["conjunction_disjunction"](Conjunctions and Disjunctions)(
        §p(
          Between §r(existential quantification), §r(universal quantification), and §r(negation), we have covered the most complicated kinds of statements. What remains are a few statements which relate the truth of other statements to each other.
        )§p(
          A §definex["conjunction"](conjunction)(
            §p(
              A §rdef(conjunction) asserts that two substatements both hold: §$(§lquote)(5 §$eq 5)() and §$(6 §$eq 6)(§rquote).
            )§p(
              You prove a §r(conjunction) by proving both of its substatements: §$(§lquote)(5 §$eq 5)() holds by definition, and §$(6 §$eq 6) holds by definition, and so the full statement holds§rquote§ .
            )
          ) asserts that two substatements are both true:
        )

        §proven_fact(
          §statement["tour_conjunction"](
            §p(§i(Claim:) §$(§$value(Alex) §$eq §$value(Alex)) and §$(§$value(Blake) §$eq §$value(Blake))(.))
          )
          §proof["tour_conjunction"](
            §p(
              §$(§$value(Alex) §$eq §$value(Alex)) holds by §r(equal)(the definition of equality), and §$(§$value(Blake) §$eq §$value(Blake)) holds by §r(equal)(the definition of equality), and so the full statement holds.
            )
          )
        )

        §p(
          As you can see, you prove a §r(conjunction) by proving both of its §side(substatements)(We have now officially reached the promised §verbatim(trivial)(or even)(boring) examples.).
        )§p(
          A §definex["disjunction"](disjunction)(
            §p(
              A §rdef(disjunction) asserts that out of two substatements at least one holds: §$(§lquote)(5 §$eq 6)() or §$(6 §$eq 6)(§rquote§ .)
            )§p(
              You prove a §r(disjunction) by proving one of its substatements: §$(§lquote)(6 §$eq 6)() holds by definition, and so the full statement holds§rquote§ .
            )
          ) asserts that out of two substatements at least one is true:
        )

        §proven_fact(
          §statement["tour_disjunction"](
            §p(§i(Claim:) §$(§$value(Alex) §$eq §$value(Charlie)) or §$(§$value(Blake) §$eq §$value(Blake))(.))
          )
          §proof["tour_disjunction"](
            §p(
              §$(§$value(Blake) §$eq §$value(Blake)) holds by §r(equal)(the definition of equality), and so the full statement holds.
            )
          )
        )

        §p(
          Unsurprisingly enough, you prove a §r(disjunction) by proving one of its substatements. The following two examples demonstrate the remaining two constellations of substatement truth which result in a true §r(disjunction).
        )

        §proven_fact(
          §statement["tour_disjunction2"](
            §p(§i(Claim:) §$(§$value(Alex) §$eq §$value(Alex)) or §$(§$value(Blake) §$eq §$value(Charlie))(.))
          )
          §proof["tour_disjunction2"](
            §p(
              §$(§$value(Alex) §$eq §$value(Alex)) holds by §r(equal)(the definition of equality), and so the full statement holds.
            )
          )
        )

        §proven_fact(
          §statement["tour_disjunction3"](
            §p(§i(Claim:) §$(§$value(Alex) §$eq §$value(Alex)) or §$(§$value(Blake) §$eq §$value(Blake))(.))
          )
          §proof["tour_disjunction3"](
            §p(
              §$(§$value(Alex) §$eq §$value(Alex)) holds by §r(equal)(the definition of equality), and so the full statement holds.
            )
          )
        )

        §p(
          If both substatements of a §r(disjunction) hold, you can prove either one. For example, §cref(tour_disjunction3) also admits the following proof:
        )

        §proof["tour_disjunction3", "Alternate ", "tour_disjunction3_other"](
          §p(§i(Claim:) §$(§$value(Alex) §$eq §$value(Alex)) or §$(§$value(Blake) §$eq §$value(Blake))(.))
          §p(
            §$(§$value(Blake) §$eq §$value(Blake)) holds by §r(equal)(the definition of equality), and so the full statement holds.
          )
        )

        §p(
          Whereas §verbatim(or) signifies a §r(disjunction) in a proof and thus admits the possibility of both substatements being true, in everyday language §verbatim(or) usually signifies an §em(exclusive) choice. In a formal context, the §definex["xor"](exclusive or)(
            §p(
              The §rdef(exclusive or) of two substatements asserts that exactly one of them holds.
            )
          ), which denotes that both at least and at most one — that is, exactly one — of two alternatives §verbatim(§meta1) and §verbatim(§meta2) is true, is formulated as an explicit §verbatim(§em(either))(§meta1 or)(§meta2).
        )

        §exercise["tour_xor"](
          §p(
            Using §r(negation), §r(conjunction), and §r(disjunction), construct a statement with §r(mean the same)(the same meaning) as §verbatim(either)(§highlightlow1(§$(§$value(Alex)) is hungry) or)(§highlightlow3(§$(§$value(Alex)) is asleep)).
          )§p(
            Whenever you encounter an §r(exclusive or), you can prove it by first translating it into the equivalent statement that only uses §r(negation), §r(conjunction), and §r(disjunction).
          )
          §solution["tour_xor"](
            §p(
              §highlightlow1(§$(§$value(Alex)) is hungry) and §highlightlow3(§$(§$value(Alex)) is not asleep), or §highlightlow1(§$(§$value(Alex)) is not hungry) and §highlightlow3(§$(§$value(Alex)) is asleep).
            )
          )
        )

        §p(
          Notice that whenever the §r(exclusive or) of two statements is true, then so is their §r(disjunction). Remember also that we assume every statement to be either true or false (the §r(principle of bivalence)). From these two properties, we obtain the §definex["excluded_middle"](law of excluded middle)(
            §p(
              The §rdef(law of excluded middle) states that §verbatim(§meta1)(or not)(§meta1) always holds.
            )
          ): we can always assume §verbatim(§meta1)(or not)(§meta1) to be true, no matter how simple or complicated of a statement §verbatim(§meta1) is.
        )

      )

      §hsection["utilizing_conjunction_disjunction"](Using Conjunctions and Disjunctions)(
        §p(
          Once a §r(conjunction) is proven, both of its substatements can be assumed to be true:
        )

        §proven_fact(
          §statement["tour_use_conjunction"](
            §p(
              §i(Claim:) §$(§$value(Alex) §$eq §$value(Alex))(.)
            )
          )
          §proof["tour_use_conjunction"](
            §p(
              §$(§$value(Alex) §$eq §$value(Alex)) by §cref(tour_conjunction).
            )
          )
        )

        §p(
          Using a §r(disjunction) to prove another statement is more difficult however, because either of its substatements might not be true. So it does not suffice to assume any one of the substatements and finish the proof from there. Instead, you need to demonstrate that the proof can be completed regardless of which substatement is assumed to be true. This is called a §definex["case_distinction"](case distinction)(
            §p(
              A §rdef(case distinction) is a proof technique in which you finish multiple subproofs, each assuming some statement to be true such that the §r(disjunction) of those assumptions is true.
            )
          ), and results in having to complete two independent proofs.
        )

        §proven_fact(
          §statement["tour_use_disjunction"](
            §p(
              Let §$(s) be a squirrel. Then §$(s §$neq §$value(Alex)) or §$(s §$neq §$value(Blake))(.)
            )
          )
          §proof["tour_use_disjunction"](
            §p(
              Let §$(s) be a squirrel. By the §r(law of excluded middle) we know that §$(s §$eq §$value(Alex)) or §$(s §$neq §$value(Alex))(.) We do a §r(case distinction) on §$(§lquote)(s §$eq §$value(Alex))() or §$(s §$neq §$value(Alex))(§rquote):
            )§cases(
              §case(§$(s §$eq §$value(Alex)))(
                §p(
                  If §$(s §$eq §$value(Alex))(,) then §$(s §$neq §$value(Blake))(,) so the claim holds.
                )
              )
              §case(§$(s §$neq §$value(Alex)))(
                §p(
                  If §$(s §$neq §$value(Alex))(,) the claim holds by assumption.
                )
              )
            )§p(
              As the claim holds in all cases, it is true.
            )
          )
        )

        §exercise["exercise_tour_use_disjunction"](
          §p(
            Formulate a statement that expresses that no natural number is equal to all natural numbers, and prove it.
          )
          §solution["exercise_tour_use_disjunction"](
            §p(
              §i(Claim:) There exists no natural number §$(n) such that for each natural number §$(m) holds §$(n §$eq m)(.)
            )§p(
              §i(Proof:) Let §$(n) be a natural number. We need to show that there exists a natural number §$(m) such that §$(n §$neq m)(.)  We do a §r(case distinction) on whether §$(n §$eq 0)(:)
            )§cases(
              §case["exercise_tour_use_disjunction_case1"](§$(n §$eq 0))(
                §p(
                  Define §$(m §$defeq 1)(,)§side*()(
                    A common mistake is to not provide a specific value in §cref(exercise_tour_use_disjunction_case1), but only write something along the lines of §verbatim(§$(m))(can be any natural number other than)(§$(0)). That may be true, but it does not change the fact that the only way of proving an §r(existential quantification) is to give a concrete, well-defined §r(witness). §verbatim(Any)(natural number other than)(§$(0)) is not that.§br
                    It can be helpful to explicitly tell your reader that you chose a §r(witness) arbitrarily within certain constraints. But for mathematical correctness, you always have to settle on a specific one.
                  ) then §$(m §$neq n)(.)
                )
              )
              §case(§$(n §$neq 0))(
                §p(
                  Define §$(m §$defeq 0)(,) then §$(m §$neq n)(.)
                )
              )
            )§p(
              This concludes the proof.
            )
          )
        )

        §p(
          Similar to §rs(existential quantification) and §rs(universal quantification), there are two different viewpoints on whether §rs(conjunction) or §rs(disjunction) are easier to use for proving other statements. On the one hand, a §r(conjunction) is more powerful, allowing you to use any of its substatements. On the other hand, you need to figure out which one to use, whereas you do not face such a decision when assuming a §r(disjunction).
        )

      )

      §hsection["negating_conjunction_disjunction"](Negating Conjunctions and Disjunctions)(
        §p(
          The similarities to the behavior of quantifiers continues with the way that you prove the §rs(negation) of §rs(conjunction) and §rs(disjunction).
        )§p(
          If two statements are not both true, then at least one of them has to be false. In other words, you can prove a §r(negation)(negated) §r(conjunction) by changing it to a §r(disjunction) and §r(negation)(negating) its substatements.
        )

        §proven_fact(
          §statement["tour_negation_conjunction"](
            §p(
              It does not hold that §$(§$value(Alex) §$eq §$value(Alex)) and §$(§$value(Alex) §$eq §$value(Blake))(.)
            )
          )
          §proof["tour_negation_conjunction"](
            §p(
              We can prove the statement by showing that §$(§$value(Alex) §$neq §$value(Alex)) or §$(§$value(Alex) §$neq §$value(Blake))(.) The latter holds by §r(equal)(the definition of equality).
            )
          )
        )

        §p(
          Conversely, if two statements are not both false, then at least one of them has to be true. In other words, we can prove a §r(negation)(negated) §r(disjunction) by changing it to a §r(conjunction) and §r(negation)(negating) its substatements.
        )

        §proven_fact(
          §statement["tour_negation_disjunction"](
            §p(
              It does not hold that §$(§$value(Alex) §$eq §$value(Blake)) or §$(§$value(Alex) §$eq §$value(Charlie))(.)
            )
          )
          §proof["tour_negation_disjunction"](
            §p(
              We can prove the statement by showing that §$(§$value(Alex) §$neq §$value(Blake)) and §$(§$value(Alex) §$neq §$value(Charlie))(.) Both hold by §r(equal)(the definition of equality).
            )
          )
        )

        §p(
          The two ways of proving §r(negation)(negated) §rs(conjunction) and §rs(disjunction) are collectively referred to as §definex["de_morgan"](De Morgan's laws)(
            §p(
              §rdef(De Morgan's laws) state how to prove §r(negation)(negated) §rs(conjunction) and §rs(disjunction):
            )§ul(
              §li(
                You prove a §r(negation)(negated) §r(conjunction) by changing it to a §r(disjunction) and §r(negation)(negating) its substatements.
              )§li(
                You prove a §r(negation)(negated) §r(disjunction) by changing it to a §r(conjunction) and §r(negation)(negating) its substatements.
              )
            )
          ).
        )

        §exercise["wrong_negation_conjunction"](
          §p(
            A common mistake when §r(negation)(negating) §rs(conjunction) is to propagate the §r(negation) without swapping to a §r(disjunction).
          )§p(
            Give statements §verbatim(§meta1) and §verbatim(§meta2) such that §lquote§ not §lparen(§meta1) and §rquote(§rparen(§meta2)) and §lquote§ §lparen§ not §rparen(§meta1) and §lparen§ not §rquote(§rparen(§meta2)) do not §r(mean the same).
          )
          §solution["wrong_negation_conjunction"](
            §p(
              The statement §verbatim(not)(§$(§()(§$highlightlow1(0 §$eq 0))() and)(§$(§$highlightlow3(0 §$eq 1))(§))) is true, because §verbatim(§$(§$highlightlow1(0 §$eq 0)))(and)(§$(§$highlightlow3(0 §$eq 1))) is false.
            )§p(
              The statement §lquote(§lparen(not)) §$(§$highlightlow1(0 §$eq 0))(§rparen) and §lparen(not) §$(§$highlightlow3(0 §$eq 1))(§rparen) however is false, because §verbatim(not)(§$(§$highlightlow1(0 §$eq 0))) is false.
            )
          )
        )§exercise["wrong_negation_disjunction"](
          §p(
            A common mistake when §r(negation)(negating) §rs(disjunction) is to propagate the §r(negation) without swapping to a §r(conjunction).
          )§p(
            Give statements §verbatim(§meta1) and §verbatim(§meta2) such that §lquote§ not §lparen(§meta1) or §rquote(§rparen(§meta2)) and §lquote§ §lparen§ not §rparen(§meta1) or §lparen§ not §rquote(§rparen(§meta2)) do not §r(mean the same).
          )
          §solution["wrong_negation_disjunction"](
            §p(
              The statement §verbatim(not)(§$(§()(§$highlightlow1(0 §$eq 0))() or)(§$(§$highlightlow3(0 §$eq 1))(§))) is false, because §verbatim(§$(§$highlightlow1(0 §$eq 0))) is true.
            )§p(
              The statement §lquote(§lparen(not)) §$(§$highlightlow1(0 §$eq 0))(§rparen) or §lparen(not) §$(§$highlightlow3(0 §$eq 1))(§rparen) however is true, because §verbatim(not)(§$(§$highlightlow3(0 §$eq 1))) is true.
            )
          )
        )

      )

      §hsection["meta_conjunction_disjunction"](Meta Statements for Conjunctions And Disjunctions)(
        §p(
          We can observe some simple §rs(meta statement) for §rs(conjunction) and §rs(disjunction). The order of the two substatements of a §r(conjunction) or §r(disjunction) does not matter: §verbatim(§meta1)(and)(§meta2) and §verbatim(§meta2)(and)(§meta1) §r(mean the same), as do §verbatim(§meta1)(or)(§meta2) and §verbatim(§meta2)(or)(§meta1). These laws are called the §definex["conjunction_commutativity"](commutative conjunction)(blarg)(commutativity)(
            §p(
              The §rdef(commutative conjunction)(commutativity) of §rs(conjunction) states that, after swapping the order of the substatements of a §r(conjunction), the old and new statement are §r(bi-implication)(equivalent):
            )§p(
              §div(centered)(§meta1 and §meta2 §$(§$iff) §meta2 and §meta1)
            )
          ) of §rs(conjunction) and the §definex["disjunction_commutativity"](commutative disjunction)(blarg)(commutativity)(
            §p(
              The §rdef(commutative disjunction)(commutativity) of §rs(disjunction) states that, after swapping the order of the substatements of a §r(disjunction), the old and new statement are §r(bi-implication)(equivalent):
            )§p(
              §div(centered)(§meta1 or §meta2 §$(§$iff) §meta2 or §meta1)
            )
          ) of §rs(disjunction) respectively.
        )§p(
          Because a §r(conjunction) has §em(exactly) two substatements, we technically cannot state directly that three different statements all must hold, we instead either have to say that §lquote(§meta1) and §lparen(§meta2) and §rquote(§rparen(§meta3)) or that §lquote(§lparen(§meta1)) and §rparen(§meta2) and §rquote(§meta3). Both ways of grouping the §rs(conjunction) §r(mean the same), which is why we do not require making the grouping explicit. This law is called the §definex["conjunction_associativity"](associative conjunction)(blarg)(associativity)(
            §p(
              The §rdef(associative conjunction)(associativity) of §rs(conjunction) states that all ways of grouping multiple successive §rs(conjunction) are §r(bi-implication)(equivalent):
            )§p(
              §div(centered)(§parens(§meta1)(and)(§meta2) and §meta3 §$(§$iff) §meta1 and §parens(§meta2)(and)(§meta3))
            )
          ) of §rs(conjunction), and allows us to think in terms of §rs(conjunction) with arbitrarily many substatements.
        )§p(
          For §rs(disjunction) we have the analogous §definex["disjunction_associativity"](associative disjunction)(blarg)(associativity)(
            §p(
              The §rdef(associative disjunction)(associativity) of §rs(disjunction) states that all ways of grouping multiple successive §rs(disjunction) are §r(bi-implication)(equivalent):
            )§p(
              §div(centered)(§parens(§meta1)(or)(§meta2) or §meta3 §$(§$iff) §meta1 or §parens(§meta2)(or)(§meta3))
            )
          ) of §rs(disjunction), and we can accordingly think in terms of §rs(disjunction) with arbitrarily many substatements. We even allow §rs(case distinction) with more than two cases, as long as the §r(disjunction) over all cases is known to be true.
        )

        §exercise["exercise_associativity_conjunction_disjunction"](
          §p(
            Show that the grouping of §rs(conjunction) and §rs(disjunction) does matter when they both occur, by giving two statements that only differ in that grouping, proving one of them, and disproving the other.
          )
          §solution["exercise_associativity_conjunction_disjunction"](
            §p(
              §i(Claim:) §$(§()(§$highlightlow1(0 §$eq 1))() and §$(§$highlightlow3(1 §$eq 2))(§)) or §$(§$highlightlow5(0 §$eq 0))(.) This claim is true, because §$(§lquote)(§$highlightlow5(0 §$eq 0))(§rquote) holds.
            )§p(
              §i(Claim:) §$(§$highlightlow1(0 §$eq 1)) and §$(§()(§$highlightlow3(1 §$eq 2))() or §$(§$highlightlow5(0 §$eq 0))(§).) This claim is false, because §$(§lquote)(§$highlightlow1(0 §$eq 1))(§rquote) does not hold.
            )
          )
        )

        §exercise["exercise_analogies_conjunction_quantification"](
          §p(
            Find and summarize as many of the analogies between the properties of §r(conjunction)/§r(disjunction) and §r(universal quantification)(universal)/§r(existential quantification) as you can.
          )
          §solution["exercise_analogies_conjunction_quantification"](
            §ul(
              §li(
                §Rs(universal quantification) require something of §em(all) objects, and §rs(conjunction) of §em(all) substatements. §Rs(existential quantification) require something of §em(at least one) object, and §rs(disjunction) of §em(at least one) substatement.
              )§li(
                Changing a true §r(universal quantification) into an §r(existential quantification) preserves truth, as does changing a true §r(conjunction) into a §r(disjunction). Changing a false §r(existential quantification) into a §r(universal quantification) preserves falsehood, as does changing a false §r(disjunction) into a §r(conjunction).
              )§li(
                §R(negation) is propagated past a quantifier by swapping the quantifier and §r(negation)(negating) the substatement. §R(negation) is propagated past a §r(conjunction) or §r(disjunction) by swapping to the other and §r(negation)(negating) the substatements.
              )§li(
                §p(
                  Proving §rs(universal quantification) and §rs(conjunction) requires more powerful arguments than proving §rs(existential quantification) and §rs(disjunction) respectively. The prior talk about §em(multiple) substatements or object respectively at a time, whereas the latter only talk about §em(individual) ones.
                )§p(
                  Proving §rs(existential quantification) and §rs(disjunction) requires more intelligent choice however, because you need to choose a suitable object or substatement respectively from multiple options.
                )
              )§li(
                §p(
                  Using §rs(existential quantification) and §rs(disjunction) requires more powerful follow-up arguments than using §rs(universal quantification) and §rs(conjunction): §rs(existential quantification) give you a single, mostly featureless object whereas §rs(universal quantification) give you additional information about any object of your choice, and §rs(disjunction) require you to solve multiple cases whereas §rs(conjunction) simply advance the proof.
                )§p(
                  Using §rs(universal quantification) and §rs(conjunction) requires more intelligent choice however: you need to choose which object or substatement respectively to gain more information about.
                )
              )§li(
                §p(
                  The grouping amongst multiple, successive §rs(universal quantification) does not matter, neither does that of multiple, successive §rs(existential quantification). The same story holds for §rs(conjunction) and §rs(disjunction). But when interleaving §rs(universal quantification) and §rs(existential quantification), or when interleaving §rs(conjunction) and §rs(disjunction), different groupings can lead to statements that do not §r(mean the same).
                )
              )
            )
          )
        )

      )

      §hsection["implications"](Implications)(
        §p(
          §R(deductive reasoning) is about deriving statements from other statements. Whether some statement — the §definex["conclusion"](conclusion)(
            §p(
              An §rdef(implication) asserts that from a §rdef(premise) follows a §rdef(conclusion): §lquote§ If §$(x §$eq x)(,) then §$(x §$eq x)(§rquote§ .)
            )§p(
              You prove an §r(implication) by assuming the §r(premise) to be true and then proving the §r(conclusion): §verbatim(Assume)(§$(x §$eq x)(,) then §$(x §$eq x) by)(assumption).
            )
          ) — can be derived from some other statement — the §definex["premise"](premise)(
            §p(
              An §rdef(implication) asserts that from a §rdef(premise) follows a §rdef(conclusion): §lquote§ If §$(x §$eq x)(,) then §$(x §$eq x)(§rquote§ .)
            )§p(
              You prove an §r(implication) by assuming the §r(premise) to be true and then proving the §r(conclusion): §verbatim(Assume)(§$(x §$eq x)(,) then §$(x §$eq x) by)(assumption).
            )
          ) — is in itself either true or false, that is, it is a statement itself. Such a statement is called an §definex["implication"](implication)(
            §p(
              An §rdef(implication) asserts that from a §rdef(premise) follows a §rdef(conclusion): §lquote§ If §$(x §$eq x)(,) then §$(x §$eq x)(§rquote§ .)
            )§p(
              You prove an §r(implication) by assuming the §r(premise) to be true and then proving the §r(conclusion): §verbatim(Assume)(§$(x §$eq x)(,) then §$(x §$eq x) by)(assumption).
            )
          ).
        )
        §set_math_id["implies", "implication"]
        §set_math_id["impliedby", "implication"]

        §proven_fact(
          §statement["tour_implication"](
            §p(
              Let §$(n) be a natural number. If §$(n §$leq 5)(,) then §$(n §$leq 7)(.)
            )
          )
          §proof["tour_implication"](
            §p(
              Assume §$(n §$leq 5)(.) From the definition of §verbatim(§$(§$leq)) obtain §$(k) such that §$(n + k §$eq 5)(.)
            )§p(
              If §$(n + k §$eq 5)(,) then also §$(§$p(n + k) + 2 §$eq 5 + 2)(,) then also §$(§$p(n + k) + 2 §$eq 7)(,) then also §$(n + §$p(k + 2) §$eq 7)(,) and thus, because §$(k + 2) is a natural number, §$(n §$leq 7)(.)
            )
          )
        )

        §p(
          You prove an §r(implication) by assuming the §r(premise) to hold and then proving the §side(§r(conclusion))(If the §r(conclusion) holds even without assuming the §r(premise), the §r(implication) is true, albeit rather uninteresting.). Note that the truth of an §r(implication) has no bearing on the truth of its §r(premise) or its §r(conclusion) in isolation. Considering §cref(tour_implication), there exist both numbers which are §r(less than or equal to) §$(5) as well as numbers that are not §r(less than or equal to) §$(5)(,) same for §$(7)(.) But we do know that there exist no numbers which are both §r(less than or equal to) §$(5) and not §r(less than or equal to) §$(7)(.)
        )§p(
          The proof of §cref(tour_implication) consists primarily of a chain of §lquote§ if §meta1§ , then also §rquote(§meta2) fragments, that is, it consists of many successive §rs(implication). A more readable way of writing such proofs is by separating those statements with double arrows §parens(§verbatim(§$(§$implies))), particularly if the implications connect mathematical symbols rather than natural language statements:
        )

        §drop(
          §theorem*["tour_monotonicity_addition"](Monotonicity of Addition)(
            §p(
              Let §$(n)(,) §$(m)(,) and §$(k) be natural numbers. Then
            )
            §$$(
              n §$leq m §$implies n + k §$leq m + k.
            )
          )

          §theorem*["tour_associativity_addition"](Associativivity of Addition)(
            §p(
              Let §$(a)(,) §$(b)(,) and §$(c) be natural numbers. Then
            )
            §$$(
              a + §$p(b + c) §$eq §$p(a + b) + c.
            )
          )
        )

        §proof["tour_implication", "More Readable ", "tour_implication_readable"](
          §p(Let §$(n) be a natural number.)
          §p(
            §i(Claim:) If §$(n §$leq 5)(,) then §$(n §$leq 7)(.)
          )
          §p(
            §i(Proof:) Assume §$(n §$leq 5)(.) From the definition of §verbatim(§$(§$leq)) obtain §$(k) such that §$(n + k §$eq 5)(.) Then
          )§$$align*(
            && n + k &§$eq 5
          )(
            §$implies {} && §$p(n + k) + 2 &§$eq 5 + 2 §$tag(§cref(tour_monotonicity_addition)(Monotonicity) $+$)
          )(
            §$implies {} && §$p(n + k) + 2 &§$eq 7 §$tag(Definition $+$)
          )(
            §$implies {} && n + §$p(k + 2) &§$eq 7 §$tag(§cref(tour_associativity_addition)(Associativity) $+$)
          )(
            §$implies {} && n &§$leq 7. §$tag(§cref(leq)(Definition) $§$leq[true]$)
          )
        )

        §p(
          A nice benefit of laying out a proof like this is that we can annotate each line with the reason why the §r(implication) holds.
        )

        §proven_fact(
          §theorem["transitivity_leq"](Transitivity of §$(§$leq[true]))(
            §p(
              Let §$(a)(,) §$(b)(,) and §$(c) be natural numbers.
              If §$(a §$leq b) and §$(b §$leq c)(,) then §$(a §$leq c)(.)
            )
          )
          §proof["transitivity_leq"](
            §proof_as_exercise["exercise_transitivity_leq"](
              §p(
                Let §$(a)(,) §$(b)(,) and §$(c) be natural numbers.
              )§p(
                Assume that §$(a §$leq b) and obtain §$(k) such that §$(a + k §$eq b)(.) Furthermore, assume that §$(b §$leq c) and obtain §$(k')§side()(Pronounced §verbatim(k)(prime), a common way of generating new, uninventive names.) such that §$(b + k' §$eq c)(.)
              )§p(
                Define §$(k'' §$defeq k + k')(.) Then
              )§$$align*(
                a + k'' &§$eq a + §$p(k + k'') §$tag(Definition $k''$)
              )(
                &§$eq §$p(a + k) + k' §$tag(§cref(tour_associativity_addition)(Associativity) $+$)
              )(
                &§$eq b + k' §$tag(Choice of $k$)
              )(
                &§$eq c, §$tag(Choice of $k'$)
              )§p(
                and thus §$(a §$leq c)(.)
              )
            )
          )
        )

        §exercise["exercise_exactly_one"](
          §p(
            Formulate a statement that expresses that §em(exactly one) natural number is §r(less than or equal to) §$(0)(.) The suggested solution makes elegant use of an §r(implication).
          )
          §solution["exercise_exactly_one"](
            §p(
              Stating that there exists §verbatim(exactly)(one) object with a certain property can be done by stating that there exists both §verbatim(at)(least)(one) and §verbatim(at)(most)(one) such object. The §verbatim(§highlightlow2(at least)) part is regular §r(existential quantification), the interesting part is expressing the §verbatim(§highlightlow4(at most)) constraint:
            )§p(
              §highlightlow2(There exists a natural number §$(n) such that §$(n §$leq 0)), and§br§highlightlow4(for all natural numbers §$(x, y) holds that if both §$(x §$leq 0) and §$(y §$leq 0)(,) then §$(x §$eq y)).
            )
          )
        )

        §p(
          §Rs(implication) are so common that various phrases and symbols are in use for expressing them; all of the following formulations denote an §r(implication) with §r(premise) §verbatim(§meta1) and §r(conclusion) §verbatim(§meta2):
        )§ul(
          §li(§verbatim(§meta1 implies §meta2),)
          §li(§verbatim(if §meta1§ , then §meta2),)
          §li(§verbatim(whenever §meta1§ , also §meta2),)
          §li(§verbatim(from §meta1 follows §meta2),)
          §li(§verbatim(§meta2 follows from §meta1),)
          §li(§verbatim(§meta1 §$(§$implies) §meta2),)
          §li(§verbatim(§meta2 §$(§$impliedby) §meta1),)
          §li(§verbatim(§meta1 is sufficient for §meta2),)
          §li(§verbatim(§meta2 is necessary for §meta1).)
        )

      )

      §hsection["utilizing_implications"](Using Implications)(
        §p(
          Once an §r(implication) is proven, you can show that its §r(conclusion) holds by proving its §r(premise):
        )

        §proven_fact(
          §statement["tour_use_implication"](
            §p(
              §i(Claim:) §$(3 §$leq 7)(.)
            )
          )
          §proof["tour_use_implication"](
            §p(
              §$(3 §$leq 5) because §$(3 + 2 §$eq 5)(.) With §cref(tour_implication) follows that §$(3 §$leq 7)(.)
            )
          )
        )

        §p(
          Now consider a situation where §verbatim(§meta1) §r(implication)(implies) §verbatim(§meta2), and §verbatim(§meta2) §r(implication)(implies) §verbatim(§meta3). Then we also know that §verbatim(§meta1) §r(implication)(implies) §verbatim(§meta3), because if we can assume §verbatim(§meta1), then the first §r(implication) gives us §verbatim(§meta2), from which the second §r(implication) gives us §verbatim(§meta3). This property of §rs(implication) is called the §definex["transitivity_implication"](transitive implication)(blarg)(transitivity)(
            §p(
              The §rdef(transitive implication)(transitivity) of §rs(implication) states that if §verbatim(§meta1) §r(implication)(implies) §verbatim(§meta2), and §verbatim(§meta2) §r(implication)(implies) §verbatim(§meta3), then §verbatim(§meta1) §r(implication)(implies) §verbatim(§meta3).
            )
          ) of §rs(implication), and it is crucial to §r(deductive reasoning): the §r(transitive implication)(transitivity) of §rs(implication) is the reason why we can prove statements by chaining together multiple small steps where each step §r(implication)(implies) the next one.
        )

      )

      §hsection["negating_implication"](Negating Implications)(
        §p(
          An §r(implication) expresses that its §r(conclusion) cannot be false while its §r(premise) is true. Consequently you disprove an §r(implication), or equivalently, you prove a §r(negation)(negated) §r(implication), by showing that its §r(premise) holds but its §r(conclusion) does not.
        )

        §proven_fact(
          §statement["tour_negation_implication"](
            §p(
              §i(Claim:) §$(§$value(Alex) §$eq §$value(Alex)) does not imply that §$(§$value(Alex) §$eq §$value(Blake))(.)
            )
          )
          §proof["tour_negation_implication"](
            §p(
              §$(§$value(Alex) §$eq §$value(Alex)) holds but §$(§$value(Alex) §$eq §$value(Blake)) does not.
            )
          )
        )

        §p(
          We can derive another §r(meta statement) from a similar line of reasoning. If the §r(conclusion) of an §r(implication) does not hold, then the §r(premise) of the §r(implication) cannot hold either. This reformulation of an §r(implication) is called its §definex["contrapositive"](contrapositive)(
            §p(
              The §rdef(contrapositive) of an §r(implication) §verbatim(§meta1)(implies)(§meta2) is §lquote(§lparen(not)) §rparen(§meta2) implies §lparen(not) §rquote(§rparen(§meta1)).
            )
          ): the §r(contrapositive) of §verbatim(§meta1)(implies)(§meta2) is §lquote(§lparen(not)) §rparen(§meta2) implies §lparen(not) §rquote(§rparen(§meta1)). An §r(implication) and its §r(contrapositive) §r(mean the same), this is called the law of §definex["contraposition"](contraposition)(
            §p(
              The law of §rdef(contraposition)(contraposition) states that an §r(implication) and its §r(contrapositive) are §r(bi-implication)(equivalent):
            )§p(
              §div(centered)(§meta1 implies §meta2 §$(§$iff) §parens(not §meta2) implies §parens(not §meta1))
            )
          ).
        )

        §proven_fact(
          §statement["tour_contraposition"](
            §p(
              Let §$(n) be a natural number. If §$(n) is not §r(less than or equal to) §$(7)(,) then §$(n) is not §r(less than or equal to) §$(5)(.)
            )
          )
          §proof["tour_contraposition"](
            §p(
              The statement is the §r(contrapositive) of §cref(tour_implication) and thus holds by the law of §r(contraposition).
            )
          )
        )

      )

      §hsection["absurd_implications"](Absurd Implications)(
        §p(
          Any time you prove an §r(implication), you start by assuming its §r(premise) to be true. So what happens if the premise is a false statement? Perhaps surprisingly, the §r(implication) as a whole turns out to be true in that case. We demonstrate this with an example:
        )

        §proven_fact(
          §statement["absurd"](
            §p(
              If §$(0 §$eq 1)(,) then §$(§$value(Alex)) is currently eating pumpkin pie in a hot air balloon.
            )
          )
          §proof["absurd"](
            §p(
              Assume §$(0 §$eq 1)(.) Further notice that §$(0 §$neq 1) holds by §r(equal)(the definition of equality). Thus also the §r(disjunction) §$(§lquote)(0 §$neq 1)() or §$(§$value(Alex)) is currently eating pumpkin pie in a hot air balloon§rquote holds.
            )§p(
              Because §$(0 §$eq 1)(,) the first substatement of that §r(disjunction) cannot be true, so the second substatement has to be. Thus, we have shown that §$(§$value(Alex)) is currently eating pumpkin pie in a hot air balloon.
            )
          )
        )

        §p(
          Eating pumpkin pie in a hot air balloon is rather atypical behavior for squirrels, and yet, we were able to prove it when assuming a falsehood. In fact, we could have proven §em(any) statement, including even that §$(§$value(Alex)) is §em(not) currently eating pumpkin pie in a hot air balloon. The fact that every statement can be proven from a falsehood is vivaciously called the §definex(principle of explosion)(
            §p(
              The §rdef(principle of explosion) states that from a falsehood every statement can be proven.
            )
          ).
        )§p(
          When proving an §r(implication) with a false premise, we get to assume a falsehood to hold. By the §r(principle of explosion), we can then prove any statement. In particular, we can prove the §r(conclusion) of the §r(implication), and if we can prove the §r(conclusion) by assuming the §r(premise), then the §r(implication) as a whole holds.
        )§p(
          This can lead to statements to whose truth it might take some getting used to, such as the one in the following exercise:
        )

        §exercise["exercise_absurd"](
          §p(
            Prove that there exists a squirrel §$(s) such that §$(s §$eq §$value(Alex)) implies §$(s §$eq §$value(Blake))(.)
          )
          §solution["exercise_absurd"](
            §p(
              Define §$(s §$defeq §$value(Charlie))(,) then §$(s §$eq §$value(Alex)) is false, and the §r(implication) as a whole holds by the §r(principle of explosion).
            )
          )
        )

        §p(
          Knowing how §rs(implication) with false §rs(premise) behave, we can examine why §r(negation)(negating) §rs(implication) is a less symmetric procedure than §r(negation)(negating) §rs(conjunction) and §rs(disjunction):
        )

        §exercise["wrong_negation_implication"](
          §p(
            A common mistake when §r(negation)(negating) §rs(implication) is to simply negate both the §r(premise) and the §r(conclusion) and call it a day.
          )§p(
            Give statements §verbatim(§meta1) and §verbatim(§meta2) such that §verbatim(§meta1)(does not imply)(§meta2) and §verbatim(not)(§meta1 implies not)(§meta2) do not §r(mean the same).
          )
          §solution["wrong_negation_implication"](
            §p(
              The statement §verbatim(§$(§$highlightlow1(0 §$eq 1)))(does not imply)(§$(§$highlightlow3(1 §$eq 2))) is false, because §verbatim(§$(§$highlightlow1(0 §$eq 1)))(implies)(§$(§$highlightlow3(1 §$eq 2))) is true by the §r(principle of explosion).
            )§p(
              The statement §verbatim(§$(§$highlightlow1(0 §$neq 1)))(implies)(§$(§$highlightlow3(1 §$neq 2))) is true however, because both §verbatim(§$(§$highlightlow1(0 §$neq 1))) and §verbatim(§$(§$highlightlow3(1 §$neq 2))) are true.
            )
          )
        )§exercise["wrong_negation_implication2"](
          §p(
            A common mistake when §r(negation)(negating) §rs(implication) is to simply swap the §r(premise) and the §r(conclusion) and call it a day.
          )§p(
            Give statements §verbatim(§meta1) and §verbatim(§meta2) such that §verbatim(§meta1)(does not imply)(§meta2) and §verbatim(§meta2)(implies)(§meta1) do not §r(mean the same).
          )
          §solution["wrong_negation_implication2"](
            §p(
              The statement §verbatim(§$(§$highlightlow1(0 §$eq 1)))(does not imply)(§$(§$highlightlow3(1 §$eq 2))) is false, because §verbatim(§$(§$highlightlow1(0 §$eq 1)))(implies)(§$(§$highlightlow3(1 §$eq 2))) is true by the §r(principle of explosion).
            )§p(
              The statement §verbatim(§$(§$highlightlow3(1 §$eq 2)))(implies)(§$(§$highlightlow1(0 §$eq 1))) is, also by the §r(principle of explosion), true however.
            )
          )
        )
        §exercise["exercise_wrong_negations_implication"](
          §p(
            How are the incorrect attempts at §r(negation)(negating) §rs(implication) of §cref(wrong_negation_implication) and §cref(wrong_negation_implication2) related?
          )
          §solution["exercise_wrong_negations_implication"](
            §p(
              The statement §verbatim(if)(not §meta1 then not)(§meta2) is the §r(contrapositive) of the statement §verbatim(if)(§meta2 then)(§meta1).
            )
          )
        )

      )

      §hsection["contradictions"](Proofs by Contradiction)(
        §p(
          §Rs(implication) with a false §r(premise) always hold, but what about §rs(implication) with a false §r(conclusion)? If the §r(implication) is to hold, we must be able to prove its §r(conclusion), which should be impossible if the §r(conclusion) is false. Except, of course, if the §r(premise) is false as well. So we can observe the following: If an §r(implication) with a false §r(conclusion) holds, its §r(premise) must be false.
        )§p(
          We can use this as a proof technique: If we can manage to prove a falsehood by assuming the §r(negation) of some statement, then the §r(negation) of that statement must have been false, and thus, the original statement must have been §side(true)(This may seem like a rather convoluted approach when described abstractly, but we will see many surprisingly elegant examples throughout the book.). Such a proof is called a §definex["proof_by_contradiction"](proof by contradiction)(
            §p(
              A §rdef(proof by contradiction) shows a statement by assuming its negation and deriving a falsehood from it.
            )
          ), §verbatim(contradiction) being synonymous to §verbatim(falsehood) in this context.
        )

        §proven_fact(
          §statement["tour_contradiction"](
            §p(
              There is no squirrel §$(s) such that for each squirrel §$(t) holds §$(s §$eq t)(.)
            )
          )
          §proof["tour_contradiction"](
            §p(
              Suppose toward a contradiction that there exists a squirrel §$(s) such that for each squirrel §$(t) holds §$(s §$eq t)(.)
            )§p(
              Then we know that both §$(s §$eq §$value(Alex)) and §$(s §$eq §$value(Blake))(,) and thus §$(§$value(Alex) §$eq §$value(Blake))(.) This is a contradiction, the assumption must have been false, and thus, the original statement must be true.
            )
          )
        )

      )

      §hsection["biimplications"](Bi-implications)(
        §p(
          When two statements §r(implication)(imply) each other, then either both of them or neither of them have to hold. This is called a §definex["bi_implication"](bi-implication)(
            §p(
              A §rdef(bi-implication) asserts that two statements §r(implication)(imply) each other: §$(§lquote)(5 §$eq 6)() if and only if §$(6 §$eq 7)(§rquote§ .)
            )§p(
              You prove a §r(bi-implication) by proving both §rs(implication) separately.
            )
          ).
        )

        §proven_fact(
          §statement["tour_iff"](
            §p(
              §i(Claim:) §$(5 §$eq 6) if and only if §$(6 §$eq 7)(.)
            )
          )
          §proof["tour_iff"](
            §proof_part(
              §verbatim(§$(§$implies)):
            )(
              §p(
                Assume §$(5 §$eq 6)(.) Then, by the §r(principle of explosion), §$(6 §$eq 7)(.)
              )
            )
            §proof_part(
              §verbatim(§$(§$impliedby)):
            )(
              §p(
                Assume §$(6 §$eq 7)(.) Then, by the §r(principle of explosion), §$(5 §$eq 6)(.)
              )
            )
          )
        )

        §p(
          You prove a §r(bi-implication) by proving both §rs(implication) separately. You prove a §r(negation)(negated) §r(bi-implication) by disproving either of the §rs(implication).
        )§p(
          A common variation on proving both §rs(implication) is to prove one of them directly and to prove the §r(contrapositive) of the other:
        )

        §proven_fact(
          §statement["tour_iff2"](
            §p(
              §i(Claim:) §$(5 §$eq 6) if and only if §$(6 §$eq 7)(.)
            )
          )
          §proof["tour_iff2"](
            §proof_part(
              §verbatim(§$(5 §$eq 6 §$implies 6 §$eq 7)):
            )(
              §p(
                Assume §$(5 §$eq 6)(.) Then, by the §r(principle of explosion), §$(6 §$eq 7)(.)
              )
            )
            §proof_part(
              §verbatim(§$(5 §$neq 6 §$implies 6 §$neq 7)):
            )(
              §p(
                §$(6 §$neq 7) by §r(equal)(the definition of equality).
              )
            )
          )
        )

        §p(
          There are a few different ways of formulating §rs(bi-implication):
        )§ul(
          §set_math_id["iff", "bi_implication"]
          §li(§verbatim(§meta1 if and only if §meta2))
          §li(§verbatim(§meta1 iff §meta2))
          §li(§verbatim(§meta1 exactly if §meta2))
          §li(§verbatim(§meta1 is equivalent to §meta2))
          §li(§verbatim(§meta1 and §meta2 imply each other))
          §li(§verbatim(§meta1 §$(§$iff) §meta2))
        )

        §p(
          Furthermore, the concept of statements that §r(mean the same) is exactly that of statements that §side(§r(bi-implication)(imply each other))(We simply did not have the necessary terminology available when first introducing §rs(meta statement). From now on, we use more standard §r(bi-implication) terminology when formulating §rs(meta statement).).
        )§p(
          Finally, every definition establishes a §r(bi-implication) between the newly-defined terminology and its meaning. By convention, definitions usually leave the §verbatim(only if) implicit. For example, we write §lquote§ a squirrel is a §define["frob1"](frob) §em(if) §rquote(§meta1) rather than §lquote§ a squirrel is a §define["frob2"](frob2)()(frob) §em(if and only if) §rquote(§meta1). This is technically incorrect, but so widely-spread that there is little point in fighting §side(it)(The correct reading is so intuitively obvious to most people that they never even detect the ambiguity. Few people read the definition of §$(§$leq) and conclude that there is no information on whether §$(5 §$leq 4) is true or not.).
        )

      )

      §hsection["meta_biimplication"](Meta Statements for Bi-Implications)(
        §p(
          Similar to §rs(conjunction) and §rs(disjunction), the order of the two substatements of a §r(bi-implication) does not matter: §verbatim(§meta1)(if and only if)(§meta2) and §verbatim(§meta2)(if and only if)(§meta1) §r(bi-implication)(are equivalent). This law is called the §definex["biimplication_commutativity"](commutative bi-implication)(blarg)(commutativity)(
            §p(
              The §rdef(commutative bi-implication)(commutativity) of §rs(bi-implication) states that, after swapping the order of the substatements of a §r(bi-implication), the old and new statement are §r(bi-implication)(equivalent):
            )§p(
              §div(centered)(§meta1 iff §meta2 §$(§$iff) §meta2 iff §meta1)
            )
          ) of §rs(bi-implication).
        )§p(
          Furthermore, §rs(bi-implication) inherit the §r(transitive implication)(transitivity) of §rs(implication) and are thus §definex["transitivity_biimplication"](transitive bi-implication)(blarg)(transitive)(
            §p(
              The §rdef(transitive bi-implication)(transitivity) of §rs(bi-implication) states that if §verbatim(§meta1)(if and only if)(§meta2) and §verbatim(§meta2)(if and only if)(§meta3), then also §verbatim(§meta1)(if and only if)(§meta3).
            )
          ) themselves: if §verbatim(§meta1)(if and only if)(§meta2) and §verbatim(§meta2)(if and only if)(§meta3), then also §verbatim(§meta1)(if and only if)(§meta3).
        )§p(
          The §r(transitive bi-implication)(transitivity) of §rs(bi-implication) reduces the number of individual proofs you need for showing that several statements are pairwise §r(bi-implication)(equivalent). You can save even more work by showing that they §r(implication)(imply) each other cyclically: if §verbatim(§meta1) §r(implication)(implies) §verbatim(§meta2), §verbatim(§meta2) §r(implication)(implies) §verbatim(§meta3), and §verbatim(§meta3) §r(implication)(implies) §verbatim(§meta1), then §verbatim(§meta1), §verbatim(§meta2), and §verbatim(§meta3) are all §r(bi-implication)(equivalent) to each other. This generalizes to larger numbers of statements as well.
        )

      )

    )

    §hsection["deductive_reasoning_conclusion"](Conclusion)(
      §p(
        This wraps up the overview of our system of §r(deductive reasoning). We denote objects of interest by §rs(term), combine §rs(term) into statements via §rs(predicate), and build up more complex statements from there. We acquire knowledge by proving statements, letting the types of statements determine how the proofs must work. §cref(summary_statements) summarizes the different types of statements that we use.
      )

      §figure["summary_statements", "wide"](Table of Statements)(
        §captioned(
          §table(
            §thead(
              §tr(
                §th(Statement)
                §th(Proving)
                §th(Using)
                §th(Handling Negation)
              )
            )
            §tbody(
              §tr(
                §td(§R(existential quantification):§br§ §verbatim(There)(exists §$(x) such that)(§meta1).)
                §td(Provide a §r(witness):§br§verbatim(Define)(§$(x §$defeq §$ldots)).)
                §td(Can obtain §r(witness).)
                §td(Swap to §r(universal quantification), move §r(negation) inside.)
              )§tr(
                §td(§R(universal quantification):§br§ §verbatim(For)(each §$(x) holds)(§meta1).)
                §td(Prove for arbitrary object:§br§verbatim(Let)(§$(x) be something,)(then…).)
                §td(Can assume §verbatim(§meta1) for any object.)
                §td(Swap to §r(existential quantification), move §r(negation) inside.)
              )§tr(
                §td(§R(negation):§br § §verbatim(It)(does not hold that)(§meta1).)
                §td(Varies by type of §r(negation)(negated) statement.)
                §td(Can use the statement obtained by moving the §r(negation) inside.)
                §td(§R(double negation) can be dropped.)
              )§tr(
                §td(§R(conjunction):§br§ §verbatim(§meta1)(and)(§meta2).)
                §td(Prove both §verbatim(§meta1) and §verbatim(§meta2).)
                §td(Can assume either statement.)
                §td(Swap to §r(disjunction), move §r(negation) inside.)
              )§tr(
                §td(§R(disjunction):§br§ §verbatim(§meta1)(or)(§meta2).)
                §td(Prove §verbatim(§meta1) or §verbatim(§meta2).)
                §td(Can do a §r(case distinction).)
                §td(Swap to §r(conjunction), move §r(negation) inside.)
              )§tr(
                §td(§R(implication):§br§ §verbatim(If)(§meta1 then)(§meta2).)
                §td(Assume §verbatim(§meta1) and prove §verbatim(§meta2).)
                §td(Can prove §verbatim(§meta1) to prove §verbatim(§meta2).)
                §td(Prove §verbatim(§meta1) and disprove §verbatim(§meta2).)
              )§tr(
                §td(§R(bi-implication):§br§ §verbatim(§meta1)(if and only if)(§meta2).)
                §td(Prove §verbatim(§meta1)(§$(§$implies))(§meta2) and§br§ §verbatim(§meta2)(§$(§$implies))(§meta1).)
                §td(Proving/disproving either statement also proves/disproves the other.)
                §td(Disprove either §r(implication).)
              )
            )
          )
        )(
          §p(
            The different types of statements in our system of §r(deductive reasoning), summarized as a table.
          )
        )
      )

      §p(
        In this chapter, we have only looked at statements about numbers and squirrels, two fairly limited domains. The goal of the §cref(chapter_sets)(next chapter) is to find a class of objects of interest that can express any subject we might wish to study. Our system of §r(deductive reasoning) applied to such a universal class of objects: that's mathematics.
      )

      §hsection["caution"](Words of Caution)(
        §p(
          §R(deductive reasoning) is a powerful tool. Knowing that some conclusions you reached are provably correct makes it easy to dismiss anyone who disagrees with you. But always remember that every proof ultimately rests on certain assumptions about the objects of interest.
        )§p(
          While you might know for certain that a conclusion follows from your assumptions, you cannot know whether those assumptions were correct in the first place. Every proof is only as good as its assumptions; §r(deductive reasoning) offers guaranteed self-consistency, not absolute truths. If you start with awful assumptions, you can arrive at awful conclusions. Reaching those conclusions in a provably correct manner does not justify them at all, it is your assumptions you need to scrutinize.
        )§p(
          In mathematics, almost everyone agrees on the same assumptions, and the few points of contention are §side(well-known)(Key phrases are §link(intuitionistic logic)(https://en.wikipedia.org/wiki/Intuitionistic_logic) and the §link(axiom of choice)(https://en.wikipedia.org/wiki/Axiom_of_choice).). But the world we inhabit is complex, and human beings even more so, making it difficult or even impossible for multiple people to work from identical assumptions on real-world problems.
        )§p(
          So the next time you disagree with someone, do not assume that their logic is faulty, try to work out the differences in your assumptions instead. Do so with kindness and humility, do not become the person from the following comic:
        )

        §div(img_container)(
          §a{"href": "https://xkcd.com/1112/"}(
            <img alt="A comic about a person obnoxiously refusing to adjust their own assumptions despite facing evidence that they are incorrect." src="./assets/images/think_logically.png">
          )
          §side*()(§link(https://xkcd.com/1112/)(https://xkcd.com/1112/): §verbatim(Think Logically))
        )
      )

    )

    §hsection["exercises_deductive_reasoning"](Exercises)(
      §p(
        Every chapter of this book ends with a collection of exercises that recapitulate the contents of the chapter and have you develop related concepts on your own. Every chapter except this one that is, as you will practice your §r(deductive reasoning) skills throughout the whole book.
      )§p(
        Like every new skill, you become better at mathematics by practicing. §strong(You do not solve exercises to check whether you understood the material, you solve the exercises so that you §em(do) understand the material.) You will spend more time on thinking about exercises than on reading the book.
      )§p(
        To get the most out of these exercises, try to follow some principles:
      )§ul(
        §li(
          You do not need to solve every single exercise. If an exercise bores you, you are probably not learning anything and you can safely skip it.
        )§li(
          Always prove that your solutions are correct. If an exercise asks you to give an object that satisfies certain properties, prove that it does indeed satisfy these properties.
        )§li(
          Write down some of your solutions, you §em(will) miss crucial details if you do not. Giving written solutions to only some of the exercises will teach you more than solving all of them in your head. If you want to try out digital typesetting, the de facto standard software is §link(LaTeX)(https://www.latex-project.org/).
        )§li(
          Find other learners and talk about exercises that give you trouble. Exchange your write-ups and help each other improve them. Consider writing down solutions together.
        )§li(
          If at all possible, gather feedback on your written solutions from a more experienced mathematician. Ask them to be thorough and scrutinize your work mercilessly, in content and formal rigor as well as in style and presentation. You are not only learning new concepts, you are also getting to know a new mode of communication.
        )
      )§p(
        When writing down solutions, try to adhere to the following guidelines:
      )§ul(
        §li(
          Help your reader understand you. If the exercise asks you to either prove or disprove a statement, begin by telling the reader which of the two you will do. The reader should never need to backtrack in order to understand your solution. Omit all information that is not directly relevant to your solution.
        )§li(
          Your reader has exactly the background knowledge given in the book up to the current point. You need to convince your reader of the correctness of your solutions. Your reader does not accept your intuitive reasoning, only knowledge derived from definitions counts. Write down computations step-by-step, annotating each step with the definition or proven statement that justifies it.
        )§li(
          Introducing formal arguments with an intuitive explanation can sometimes increase legibility. If you choose to do so, clearly communicate which parts of your solution constitute guiding intuition and which parts constitute formal reasoning. No intuitive explanation should be without a formal counterpart.
        )
      )§p(
        Finally, some hints for approaching difficult exercises:
      )§ul(
        §li(
          You cannot solve an exercise you do not fully understand. Whenever you encounter a term in an exercise that you are unsure about, look up its definition. Never start an exercise if you cannot precisely define the task at hand.
        )§li(
          Examining concrete examples often leads to ideas that are applicable in general. Rather than diving directly into a proof, first get a feeling for the behavior of specific objects. Or perhaps look for counterexamples and analyze why you just cannot find any.
        )§li(
          Do not be discouraged if you struggle to solve an exercise. Always remember that you do not do exercises to measure your skills, but to hone them. The exercises you can easily solve are far less valuable than those you are having a hard time with. Keep in mind that moving on to another exercise and returning later to the difficult one can sometimes do wonders.
        )
      )

    )

    §chapternav

  )

)
